% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ct.R
\name{assert_ct_clst}
\alias{assert_ct_clst}
\title{Assert a codelist code}
\usage{
assert_ct_clst(ct_spec, ct_clst, optional = FALSE)
}
\arguments{
\item{ct_spec}{Either a data frame encoding a controlled terminology data set, or
\code{NULL}.}

\item{ct_clst}{A string with a to-be asserted codelist code, or \code{NULL}.}

\item{optional}{A scalar logical, indicating whether \code{ct_clst} can be \code{NULL} or
not.}
}
\value{
The function throws an error if \code{ct_clst} is not a valid codelist code
given the controlled terminology data set; otherwise, \code{ct_clst} is returned
invisibly.
}
\description{
\code{\link[=assert_ct_clst]{assert_ct_clst()}} asserts the validity of a codelist code in the context of
a controlled terminology specification.
}
\examples{
# Load a controlled terminology example.
(ct_spec <- read_ct_spec_example("ct-01-cm"))

# Should work fine.
sdtm.oak:::assert_ct_clst(ct_spec = ct_spec, ct_clst = "C71113")

# In certain cases, you might allow `ct_clst` to be `NULL` as to indicate absence,
# in that case, set `optional` to `TRUE` to make `assert_ct_clst()` more
# forgiving.
sdtm.oak:::assert_ct_clst(ct_spec = ct_spec, ct_clst = NULL, optional = TRUE)

# Otherwise it would err.
try(sdtm.oak:::assert_ct_clst(ct_spec = ct_spec, ct_clst = NULL, optional = FALSE))

}
\keyword{internal}
