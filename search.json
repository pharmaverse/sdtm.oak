[{"path":"https://pharmaverse.github.io/sdtm.oak/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, pledge respect people contribute reporting issues, posting feature requests, updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience, gender, gender identity expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion. Examples unacceptable behavior participants include use sexual language imagery, derogatory comments personal attacks, trolling, public private harassment, insults, unprofessional conduct. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct. Project maintainers follow Code Conduct may removed project team. Instances abusive, harassing, otherwise unacceptable behavior may reported opening issue contacting one project maintainers. Code Conduct adapted Contributor Covenant (http://contributor-covenant.org), version 1.0.0, available http://contributor-covenant.org/version/1/0/0/","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contribution to {sdtm.oak}","title":"Contribution to {sdtm.oak}","text":"outlines propose change sdtm.oak package. detailed info contributing {sdtm.oak}, pharmaverse packages, please see Contribution Guide well Developer Guides Articles section {admiraldev} website. Please note try align best practices used R packages’ development processes - veteran developers familiar processes. However, deviate slightly best practices advise new contributors review package documentation accordingly.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/CONTRIBUTING.html","id":"basics","dir":"","previous_headings":"","what":"Basics","title":"Contribution to {sdtm.oak}","text":"new contribution, user creates issue issue tab GitHub put backlog. issues can range bug identification /fixes, enhancements functions, documentation, tests new features. advise contact us issue created via Slack (don’t access, use link join). can discuss details align expectations familiar sdtm.oak philosophy programming strategy. team try review issues within next backlog meeting give initial feedback. Since 100% fully resourced software development team might issues take longer respond depending amount overall issues.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"Apache License","title":"Apache License","text":"Version 2.0, January 2004 <http://www.apache.org/licenses/>","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_1-definitions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"1. Definitions","title":"Apache License","text":"“License” shall mean terms conditions use, reproduction, distribution defined Sections 1 9 document. “Licensor” shall mean copyright owner entity authorized copyright owner granting License. “Legal Entity” shall mean union acting entity entities control, controlled , common control entity. purposes definition, “control” means () power, direct indirect, cause direction management entity, whether contract otherwise, (ii) ownership fifty percent (50%) outstanding shares, (iii) beneficial ownership entity. “” (“”) shall mean individual Legal Entity exercising permissions granted License. “Source” form shall mean preferred form making modifications, including limited software source code, documentation source, configuration files. “Object” form shall mean form resulting mechanical transformation translation Source form, including limited compiled object code, generated documentation, conversions media types. “Work” shall mean work authorship, whether Source Object form, made available License, indicated copyright notice included attached work (example provided Appendix ). “Derivative Works” shall mean work, whether Source Object form, based (derived ) Work editorial revisions, annotations, elaborations, modifications represent, whole, original work authorship. purposes License, Derivative Works shall include works remain separable , merely link (bind name) interfaces , Work Derivative Works thereof. “Contribution” shall mean work authorship, including original version Work modifications additions Work Derivative Works thereof, intentionally submitted Licensor inclusion Work copyright owner individual Legal Entity authorized submit behalf copyright owner. purposes definition, “submitted” means form electronic, verbal, written communication sent Licensor representatives, including limited communication electronic mailing lists, source code control systems, issue tracking systems managed , behalf , Licensor purpose discussing improving Work, excluding communication conspicuously marked otherwise designated writing copyright owner “Contribution.” “Contributor” shall mean Licensor individual Legal Entity behalf Contribution received Licensor subsequently incorporated within Work.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_2-grant-of-copyright-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"2. Grant of Copyright License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable copyright license reproduce, prepare Derivative Works , publicly display, publicly perform, sublicense, distribute Work Derivative Works Source Object form.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_3-grant-of-patent-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"3. Grant of Patent License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable (except stated section) patent license make, made, use, offer sell, sell, import, otherwise transfer Work, license applies patent claims licensable Contributor necessarily infringed Contribution(s) alone combination Contribution(s) Work Contribution(s) submitted. institute patent litigation entity (including cross-claim counterclaim lawsuit) alleging Work Contribution incorporated within Work constitutes direct contributory patent infringement, patent licenses granted License Work shall terminate date litigation filed.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_4-redistribution","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"4. Redistribution","title":"Apache License","text":"may reproduce distribute copies Work Derivative Works thereof medium, without modifications, Source Object form, provided meet following conditions: () must give recipients Work Derivative Works copy License; (b) must cause modified files carry prominent notices stating changed files; (c) must retain, Source form Derivative Works distribute, copyright, patent, trademark, attribution notices Source form Work, excluding notices pertain part Derivative Works; (d) Work includes “NOTICE” text file part distribution, Derivative Works distribute must include readable copy attribution notices contained within NOTICE file, excluding notices pertain part Derivative Works, least one following places: within NOTICE text file distributed part Derivative Works; within Source form documentation, provided along Derivative Works; , within display generated Derivative Works, wherever third-party notices normally appear. contents NOTICE file informational purposes modify License. may add attribution notices within Derivative Works distribute, alongside addendum NOTICE text Work, provided additional attribution notices construed modifying License. may add copyright statement modifications may provide additional different license terms conditions use, reproduction, distribution modifications, Derivative Works whole, provided use, reproduction, distribution Work otherwise complies conditions stated License.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_5-submission-of-contributions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"5. Submission of Contributions","title":"Apache License","text":"Unless explicitly state otherwise, Contribution intentionally submitted inclusion Work Licensor shall terms conditions License, without additional terms conditions. Notwithstanding , nothing herein shall supersede modify terms separate license agreement may executed Licensor regarding Contributions.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_6-trademarks","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"6. Trademarks","title":"Apache License","text":"License grant permission use trade names, trademarks, service marks, product names Licensor, except required reasonable customary use describing origin Work reproducing content NOTICE file.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_7-disclaimer-of-warranty","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"7. Disclaimer of Warranty","title":"Apache License","text":"Unless required applicable law agreed writing, Licensor provides Work (Contributor provides Contributions) “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied, including, without limitation, warranties conditions TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS PARTICULAR PURPOSE. solely responsible determining appropriateness using redistributing Work assume risks associated exercise permissions License.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_8-limitation-of-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"8. Limitation of Liability","title":"Apache License","text":"event legal theory, whether tort (including negligence), contract, otherwise, unless required applicable law (deliberate grossly negligent acts) agreed writing, shall Contributor liable damages, including direct, indirect, special, incidental, consequential damages character arising result License use inability use Work (including limited damages loss goodwill, work stoppage, computer failure malfunction, commercial damages losses), even Contributor advised possibility damages.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"id_9-accepting-warranty-or-additional-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"9. Accepting Warranty or Additional Liability","title":"Apache License","text":"redistributing Work Derivative Works thereof, may choose offer, charge fee , acceptance support, warranty, indemnity, liability obligations /rights consistent License. However, accepting obligations, may act behalf sole responsibility, behalf Contributor, agree indemnify, defend, hold Contributor harmless liability incurred , claims asserted , Contributor reason accepting warranty additional liability. END TERMS CONDITIONS","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/LICENSE.html","id":"appendix-how-to-apply-the-apache-license-to-your-work","dir":"","previous_headings":"","what":"APPENDIX: How to apply the Apache License to your work","title":"Apache License","text":"apply Apache License work, attach following boilerplate notice, fields enclosed brackets [] replaced identifying information. (Don’t include brackets!) text enclosed appropriate comment syntax file format. also recommend file class name description purpose included “printed page” copyright notice easier identification within third-party archives.","code":"Copyright [yyyy] [name of copyright owner]  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/algorithms.html","id":"core-concept","dir":"Articles","previous_headings":"","what":"Core Concept","title":"Algorithms & Sub-Algorithms","text":"SDTM mappings defined algorithms transform collected (eCRF, eDT) source data target SDTM data model. Mapping algorithms backbone {sdtm.oak} - SDTM data transformation engine. Key Points: Algorithms can re-used across multiple SDTM domains. Algorithms pre-specified data collection standards MDR (applicable) facilitate automation. Programming language agnostic - concept rely specific programming language implementation. {sdtm.oak} team implemented R functions. example reusing algorithm across multiple domains, variables, also non-standard","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/algorithms.html","id":"list-of-algorithms","dir":"Articles","previous_headings":"","what":"List of Algorithms","title":"Algorithms & Sub-Algorithms","text":"release {sdtm.oak} supports following algorithms: assign_no_ct, assign_ct, hardcode_no_ct, hardcode_ct, assign_datetime, condition_add. Rest algorithms developed subsequent releases. following table provides brief description algorithm.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/algorithms.html","id":"sub-algorithms","dir":"Articles","previous_headings":"","what":"Sub-algorithms","title":"Algorithms & Sub-Algorithms","text":"{sdtm.oak} supports two levels defining algorithms. example, SDTM mappings certain action taken condition met. cases, primary algorithm checks condition, sub-algorithm executes mappings condition met. Currently, sub-algorithms must provided main algorithms. condition_add dataset_level algorithms can interchangeably used algorithms sub-algorithms seen (exhaustive list)  permutation & combination algorithms & sub-algorithms creates endless possibilities accommodate different types mappings.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/cnd_df.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Conditioned Data Frames","text":"Conditioned data frames, cnd_df, powerful tool sdtm.oak package designed facilitate conditional transformations data frames. article explains create use conditioned data frames, particularly context SDTM domain derivations.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/cnd_df.html","id":"creating-conditioned-data-frames","dir":"Articles","previous_headings":"","what":"Creating Conditioned Data Frames","title":"Conditioned Data Frames","text":"conditioned data frame regular data frame extended logical vector cnd marks rows subsequent conditional transformations. condition_add() function used create conditioned data frames.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/cnd_df.html","id":"simple-example","dir":"Articles","previous_headings":"Creating Conditioned Data Frames","what":"Simple Example","title":"Conditioned Data Frames","text":"Consider simple data frame df: can create conditioned data frame rows x > 1 marked: , second third rows marked TRUE.","code":"(df <- tibble(x = 1L:3L, y = letters[1L:3L])) ## # A tibble: 3 × 2 ##       x y     ##   <int> <chr> ## 1     1 a     ## 2     2 b     ## 3     3 c (cnd_df <- condition_add(dat = df, x > 1L)) ## # A tibble:  3 × 2 ## # Cond. tbl: 2/1/0 ##         x y     ##     <int> <chr> ## 1 F     1 a     ## 2 T     2 b     ## 3 T     3 c"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/cnd_df.html","id":"usage-in-sdtm-domain-derivations","dir":"Articles","previous_headings":"","what":"Usage in SDTM Domain Derivations","title":"Conditioned Data Frames","text":"real power conditioned data frames manifests used functions assign_no_ct, assign_ct, hardcode_no_ct, hardcode_ct. functions perform derivations records match pattern TRUE values conditioned data frames.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/cnd_df.html","id":"example-with-concomitant-medications-cm-domain","dir":"Articles","previous_headings":"Usage in SDTM Domain Derivations","what":"Example with Concomitant Medications (CM) Domain","title":"Conditioned Data Frames","text":"Consider simplified dataset concomitant medications, want derive new variable CMGRPID (Concomitant Medication Group ID) based condition medication treatment (CMTRT) \"BENADRYL\". simplified raw Concomitant Medications data set (cm_raw): derive CMTRT variable use assign_no_ct() function map MDRAW variable CMTRT variable: create conditioned data frame target data set (tgt_dat), meaning create conditioned data frame rows CMTRT equal \"BENADRYL\" marked: Finally, derive CMGRPID variable conditionally. Using assign_no_ct(), derive CMGRPID indicates group ID medication, based conditioned target data set: Conditioned data frames sdtm.oak package provide flexible way perform conditional transformations data sets. marking specific rows transformation, users can efficiently derive SDTM variables, ensuring relevant records processed.","code":"cm_raw <- tibble::tibble(   oak_id = seq_len(14L),   raw_source = \"ConMed\",   patient_number = c(375L, 375L, 376L, 377L, 377L, 377L, 377L, 378L, 378L, 378L, 378L, 379L, 379L, 379L),   MDNUM = c(1L, 2L, 1L, 1L, 2L, 3L, 5L, 4L, 1L, 2L, 3L, 1L, 2L, 3L),   MDRAW = c(     \"BABY ASPIRIN\", \"CORTISPORIN\", \"ASPIRIN\",     \"DIPHENHYDRAMINE HCL\", \"PARCETEMOL\", \"VOMIKIND\",     \"ZENFLOX OZ\", \"AMITRYPTYLINE\", \"BENADRYL\",     \"DIPHENHYDRAMINE HYDROCHLORIDE\", \"TETRACYCLINE\",     \"BENADRYL\", \"SOMINEX\", \"ZQUILL\"   ) ) cm_raw ## # A tibble: 14 × 5 ##    oak_id raw_source patient_number MDNUM MDRAW                         ##     <int> <chr>               <int> <int> <chr>                         ##  1      1 ConMed                375     1 BABY ASPIRIN                  ##  2      2 ConMed                375     2 CORTISPORIN                   ##  3      3 ConMed                376     1 ASPIRIN                       ##  4      4 ConMed                377     1 DIPHENHYDRAMINE HCL           ##  5      5 ConMed                377     2 PARCETEMOL                    ##  6      6 ConMed                377     3 VOMIKIND                      ##  7      7 ConMed                377     5 ZENFLOX OZ                    ##  8      8 ConMed                378     4 AMITRYPTYLINE                 ##  9      9 ConMed                378     1 BENADRYL                      ## 10     10 ConMed                378     2 DIPHENHYDRAMINE HYDROCHLORIDE ## 11     11 ConMed                378     3 TETRACYCLINE                  ## 12     12 ConMed                379     1 BENADRYL                      ## 13     13 ConMed                379     2 SOMINEX                       ## 14     14 ConMed                379     3 ZQUILL tgt_dat <- assign_no_ct(   tgt_var = \"CMTRT\",   raw_dat = cm_raw,   raw_var = \"MDRAW\" ) tgt_dat ## # A tibble: 14 × 4 ##    oak_id raw_source patient_number CMTRT                         ##     <int> <chr>               <int> <chr>                         ##  1      1 ConMed                375 BABY ASPIRIN                  ##  2      2 ConMed                375 CORTISPORIN                   ##  3      3 ConMed                376 ASPIRIN                       ##  4      4 ConMed                377 DIPHENHYDRAMINE HCL           ##  5      5 ConMed                377 PARCETEMOL                    ##  6      6 ConMed                377 VOMIKIND                      ##  7      7 ConMed                377 ZENFLOX OZ                    ##  8      8 ConMed                378 AMITRYPTYLINE                 ##  9      9 ConMed                378 BENADRYL                      ## 10     10 ConMed                378 DIPHENHYDRAMINE HYDROCHLORIDE ## 11     11 ConMed                378 TETRACYCLINE                  ## 12     12 ConMed                379 BENADRYL                      ## 13     13 ConMed                379 SOMINEX                       ## 14     14 ConMed                379 ZQUILL (cnd_tgt_dat <- condition_add(tgt_dat, CMTRT == \"BENADRYL\")) ## # A tibble:  14 × 4 ## # Cond. tbl: 2/12/0 ##      oak_id raw_source patient_number CMTRT                         ##       <int> <chr>               <int> <chr>                         ## 1  F      1 ConMed                375 BABY ASPIRIN                  ## 2  F      2 ConMed                375 CORTISPORIN                   ## 3  F      3 ConMed                376 ASPIRIN                       ## 4  F      4 ConMed                377 DIPHENHYDRAMINE HCL           ## 5  F      5 ConMed                377 PARCETEMOL                    ## 6  F      6 ConMed                377 VOMIKIND                      ## 7  F      7 ConMed                377 ZENFLOX OZ                    ## 8  F      8 ConMed                378 AMITRYPTYLINE                 ## 9  T      9 ConMed                378 BENADRYL                      ## 10 F     10 ConMed                378 DIPHENHYDRAMINE HYDROCHLORIDE ## 11 F     11 ConMed                378 TETRACYCLINE                  ## 12 T     12 ConMed                379 BENADRYL                      ## 13 F     13 ConMed                379 SOMINEX                       ## 14 F     14 ConMed                379 ZQUILL derived_tgt_dat <- assign_no_ct(   tgt_dat = cnd_tgt_dat,   tgt_var = \"CMGRPID\",   raw_dat = cm_raw,   raw_var = \"MDNUM\" ) derived_tgt_dat ## # A tibble: 14 × 5 ##    oak_id raw_source patient_number CMTRT                         CMGRPID ##     <int> <chr>               <int> <chr>                           <int> ##  1      1 ConMed                375 BABY ASPIRIN                       NA ##  2      2 ConMed                375 CORTISPORIN                        NA ##  3      3 ConMed                376 ASPIRIN                            NA ##  4      4 ConMed                377 DIPHENHYDRAMINE HCL                NA ##  5      5 ConMed                377 PARCETEMOL                         NA ##  6      6 ConMed                377 VOMIKIND                           NA ##  7      7 ConMed                377 ZENFLOX OZ                         NA ##  8      8 ConMed                378 AMITRYPTYLINE                      NA ##  9      9 ConMed                378 BENADRYL                            1 ## 10     10 ConMed                378 DIPHENHYDRAMINE HYDROCHLORIDE      NA ## 11     11 ConMed                378 TETRACYCLINE                       NA ## 12     12 ConMed                379 BENADRYL                            1 ## 13     13 ConMed                379 SOMINEX                            NA ## 14     14 ConMed                379 ZQUILL                             NA"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Creating an Events SDTM domain","text":"article describes creating Events SDTM domain using sdtm.oak package. Examples currently presented tested context CM domain.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"raw-data","dir":"Articles","previous_headings":"","what":"Raw data","title":"Creating an Events SDTM domain","text":"Raw datasets can exported EDC systems format collected. example used provides raw dataset Concomitant medications, collected data represented columns subject. example, Medication Name(MDRAW), Medication Start Date (MDBDR), Start Time (MDBTM), End Date (MDEDR), End time (MDETM), etc. represented columns.format commonly used EDC systems. raw dataset presented :","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"programming-workflow","dir":"Articles","previous_headings":"","what":"Programming workflow","title":"Creating an Events SDTM domain","text":"{sdtm.oak} process one raw dataset time. Similar raw datasets (example Concomitant medications (OID - cm_raw), Targeted Concomitant Medications (OID - cm_t_raw)) can stacked together processing. Read data Create oak_id_vars Read CT Map Topic Variable assign_no_ct assign_ct assign_datetime hardcode_ct condition_add hardcode_no_ct condition_add condition_add involving target domain condition_add involving raw dataset target domain Repeat Map Topic Map Rest Repeat steps different raw datasets proceeding steps. Create SDTM derived variables Add Labels Attributes","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"readdata","dir":"Articles","previous_headings":"Programming workflow","what":"Read in data","title":"Creating an Events SDTM domain","text":"Read raw datasets environment. example, raw dataset name cm_raw. Users can read package using code:","code":"cm_raw <- read.csv(system.file(\"raw_data/cm_raw_data.csv\",   package = \"sdtm.oak\" ))"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"oakidvars","dir":"Articles","previous_headings":"Programming workflow","what":"Create oak_id_vars","title":"Creating an Events SDTM domain","text":"oak_id_vars crucial link raw datasets mapped SDTM domain. user derives SDTM variable, merged corresponding topic variable using oak_id_vars. {sdtm.oak}, variables oak_id, raw_source, patient_number considered oak_id_vars. three variables must added raw datasets. used multiple places programming. oak_id:- Type: numeric- Value: equal raw dataframe row number. raw_source:- Type: Character- Value: equal raw dataset (eCRF) name eDT dataset name. patient_number:- Type: numeric- Value: equal subject number CRF NonCRF data source. Read DM domain","code":"cm_raw <- cm_raw %>%   generate_oak_id_vars(     pat_var = \"PATNUM\",     raw_src = \"cm_raw\"   ) dm <- read.csv(system.file(\"raw_data/dm.csv\",   package = \"sdtm.oak\" ))"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"readct","dir":"Articles","previous_headings":"Programming workflow","what":"Read in CT","title":"Creating an Events SDTM domain","text":"Controlled Terminology part SDTM specification prepared user. example, study controlled terminology name sdtm_ct.csv. Users can read package using code:","code":"study_ct <- read.csv(system.file(\"raw_data/sdtm_ct.csv\",   package = \"sdtm.oak\" ))"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"maptopic","dir":"Articles","previous_headings":"Programming workflow","what":"Map Topic Variable","title":"Creating an Events SDTM domain","text":"topic variable mapped first step mapping process. primary variable SDTM domain. rest variables add definition topic variable. example, topic variable CMTRT. mapped raw dataset column MDRAW. mapping logic Map collected value cm_raw dataset MDRAW variable CM.CMTRT. mapping involve controlled terminology. assign_no_ct function used mapping. topic variable mapped, Qualifier, Identifier, Timing variables can mapped.","code":"cm <-   # Map topic variable   assign_no_ct(     raw_dat = cm_raw,     raw_var = \"MDRAW\",     tgt_var = \"CMTRT\"   )"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"maprest","dir":"Articles","previous_headings":"Programming workflow","what":"Map Rest of the Variables","title":"Creating an Events SDTM domain","text":"Qualifiers, Identifiers, Timing Variables can mapped order. example, map variable one one demonstrate different mapping algorithms.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"assign_no_ct","dir":"Articles","previous_headings":"Programming workflow > Map Rest of the Variables","what":"assign_no_ct","title":"Creating an Events SDTM domain","text":"mapping logic CMGRPID Map collected value cm_raw dataset MDNUM variable CM.CMGRPID. CMGRPID added corresponding CMTRT based ‘oak_id_vars’. calling function, parameter ‘id_vars = oak_id_vars()’ matches raw dataset ‘oak_id_vars’ ‘oak_id_vars’ cm domain created previous step. ’s important note ‘oak_id_vars’ can extended include user-defined variables. cases, three variables suffice.","code":"cm <- cm %>%   # Map CMGRPID   assign_no_ct(     raw_dat = cm_raw,     raw_var = \"MDNUM\",     tgt_var = \"CMGRPID\",     id_vars = oak_id_vars()   )"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"assign_ct","dir":"Articles","previous_headings":"Programming workflow > Map Rest of the Variables","what":"assign_ct","title":"Creating an Events SDTM domain","text":"mapping logic CMDOSU Map collected value cm_raw dataset DOSU variable CM.CMDOSU. controlled terminology used map collected value standard value. assign_ct right algorithm perform mapping.","code":"cm <- cm %>%   # Map qualifier CMDOSU   assign_ct(     raw_dat = cm_raw,     raw_var = \"DOSU\",     tgt_var = \"CMDOSU\",     ct_spec = study_ct,     ct_clst = \"C71620\",     id_vars = oak_id_vars()   )"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"assign_datetime","dir":"Articles","previous_headings":"Programming workflow > Map Rest of the Variables","what":"assign_datetime","title":"Creating an Events SDTM domain","text":"mapping logic CMSTDTC Map collected value cm_raw dataset MDBDR (start date) variable MDBTM (start time) CM.CMSTDTC. collected date value format ‘dd mmm yyyy’. collected time value ‘H”M’ format. assign_datetime function used map collected value ISO8601 format.","code":"cm <- cm %>%   # Map CMSTDTC. This function calls create_iso8601   assign_datetime(     raw_dat = cm_raw,     raw_var = c(\"MDBDR\", \"MDBTM\"),     tgt_var = \"CMSTDTC\",     raw_fmt = c(list(c(\"d-m-y\", \"dd mmm yyyy\")), \"H:M\"),     raw_unk = c(\"UN\", \"UNK\"),     id_vars = oak_id_vars()   )"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"hardcode_ct","dir":"Articles","previous_headings":"Programming workflow > Map Rest of the Variables","what":"hardcode_ct and condition_add","title":"Creating an Events SDTM domain","text":"mapping logic CMSTRTPT follows: collected value raw variable MDPRIOR raw dataset cm_raw equals 1, CM.CMSTRTPT == ''. hardcode_ct function used map CMSTRTPT involves hardcoding specific value SDTM variable controlled terminology. condition_add function filters raw dataset based particular condition, hardcode_ct function performs mapping. two functions used together, condition_add function first filters raw dataset based specified condition. Next, filtered dataset passed hardcode_ct function assign appropriate value. example illustrates hardcode_ct algorithm functions sub-algorithm condition_add. condition_add function adds additional metadata records raw dataset meets condition. Refer function documentation details. hardcode_ct function uses additional metadata find records meet criteria map accordingly.","code":"cm <- cm %>%   # Map qualifier CMSTRTPT  Annotation text is If MDPRIOR == 1 then CM.CMSTRTPT = 'BEFORE'   hardcode_ct(     raw_dat = condition_add(cm_raw, MDPRIOR == \"1\"),     raw_var = \"MDPRIOR\",     tgt_var = \"CMSTRTPT\",     tgt_val = \"BEFORE\",     ct_spec = study_ct,     ct_clst = \"C66728\",     id_vars = oak_id_vars()   )"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"hardcode_no_ct","dir":"Articles","previous_headings":"Programming workflow > Map Rest of the Variables","what":"hardcode_no_ct and condition_add","title":"Creating an Events SDTM domain","text":"mapping logic CMSTTPT follows: collected value raw variable MDPRIOR raw dataset cm_raw equals 1, CM.CMSTTPT == 'SCREENING'. hardcode_no_ct function used map CMSTTPT involves hardcoding specific value SDTM variable without controlled terminology. condition_add function filters raw dataset based particular condition, hardcode_no_ct function performs mapping.","code":"cm <- cm %>%   # Map qualifier CMSTTPT  Annotation text is If MDPRIOR == 1 then CM.CMSTTPT = 'SCREENING'   hardcode_no_ct(     raw_dat = condition_add(cm_raw, MDPRIOR == \"1\"),     raw_var = \"MDPRIOR\",     tgt_var = \"CMSTTPT\",     tgt_val = \"SCREENING\",     id_vars = oak_id_vars()   )"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"condition_add_tar","dir":"Articles","previous_headings":"Programming workflow > Map Rest of the Variables","what":"condition_add involving target domain","title":"Creating an Events SDTM domain","text":"mapping CMSTRTPT CMSTTTPT, condition_add function used raw dataset. mapping, can explore use condition_add add filter condition based target SDTM variable. mapping logic CMDOSFRQ CMTRT null, map collected value raw dataset cm_raw raw variable MDFRQ CMDOSFRQ. may may represent valid SDTM mapping actual study, can used example. mapping, condition_add function filters cm domain created previous step adds metadata records meets condition. assign_ct function uses additional metadata find records meet criteria map accordingly. Remember use additional curly braces function call using condition_add function target dataset. necessary input target dataset represented . passed previous step using {magrittr} pipe operator. Currently, limitation using nested function call . reference one input parameters, recommended approach overcome . placeholder . use {magrittr} pipe %>% operator. encourage using . {magrittr} pipe %>% operator using {sdtm.oak} functions. Another way achieve outcome moving ‘condition_by’ call one level, illustrated : required use {magrittr} pipe %>% curly braces case.","code":"cm <- cm %>%   # Map qualifier CMDOSFRQ  Annotation text is If CMTRT is not null then map   # the collected value in raw dataset cm_raw and raw variable MDFRQ to CMDOSFRQ   {     assign_ct(       raw_dat = cm_raw,       raw_var = \"MDFRQ\",       tgt_dat =  condition_add(., !is.na(CMTRT)),       tgt_var = \"CMDOSFRQ\",       ct_spec = study_ct,       ct_clst = \"C66728\",       id_vars = oak_id_vars()     )   } cm <- cm %>%   condition_add(!is.na(CMTRT)) %>%   assign_ct(     raw_dat = cm_raw,     raw_var = \"DOSU\",     tgt_var = \"CMDOSU\",     ct_spec = study_ct,     ct_clst = \"C71620\",     id_vars = oak_id_vars()   )"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"condition_add_raw_tar","dir":"Articles","previous_headings":"Programming workflow > Map Rest of the Variables","what":"condition_add involving raw dataset and target domain","title":"Creating an Events SDTM domain","text":"mapping, can explore use condition_add add filter condition based target SDTM variable. mapping logic CMMODIFY collected value MODIFY cm_raw different CM.CMTRT assign collected value CMMODIFY CM domain (CM.CMMODIFY). assign_no_ct function used map CMMODIFY involves mapping collected value SDTM variable without controlled terminology. condition_add function filters raw dataset & target dataset based particular condition, assign_no_ct function performs mapping. Another way achieve outcome moving ‘condition_by’ call one level, illustrated : required use {magrittr} pipe %>% curly braces case. Now, complete mapping rest SDTM variables.","code":"cm <- cm %>%   # Map CMMODIFY  Annotation text  If collected value in MODIFY in cm_raw is   # different to CM.CMTRT then assign the collected value to CMMODIFY in   # CM domain (CM.CMMODIFY)   {     assign_no_ct(       raw_dat = cm_raw,       raw_var = \"MODIFY\",       tgt_dat = condition_add(., MODIFY != CMTRT, .dat2 = cm_raw),       tgt_var = \"CMMODIFY\",       id_vars = oak_id_vars()     )   } cm <- cm %>%   condition_add(MODIFY != CMTRT, .dat2 = cm_raw) %>%   assign_no_ct(     raw_dat = cm_raw,     raw_var = \"MODIFY\",     tgt_var = \"CMMODIFY\",     id_vars = oak_id_vars()   ) cm <- cm %>%   # Map CMINDC as the collected value in MDIND to CM.CMINDC   assign_no_ct(     raw_dat = cm_raw,     raw_var = \"MDIND\",     tgt_var = \"CMINDC\",     id_vars = oak_id_vars()   ) %>%   # Map CMENDTC as the collected value in MDEDR and MDETM to CM.CMENDTC.   # This function calls create_iso8601   assign_datetime(     raw_dat = cm_raw,     raw_var = c(\"MDEDR\", \"MDETM\"),     tgt_var = \"CMENDTC\",     raw_fmt = c(\"d-m-y\", \"H:M\"),     raw_unk = c(\"UN\", \"UNK\")   ) %>%   # Map qualifier CMENRTPT as If MDONG == 1 then CM.CMENRTPT = 'ONGOING'   hardcode_ct(     raw_dat = condition_add(cm_raw, MDONG == \"1\"),     raw_var = \"MDONG\",     tgt_var = \"CMENRTPT\",     tgt_val = \"ONGOING\",     ct_spec = study_ct,     ct_clst = \"C66728\",     id_vars = oak_id_vars()   ) %>%   # Map qualifier CMENTPT as If MDONG == 1 then CM.CMENTPT = 'DATE OF LAST ASSESSMENT'   hardcode_no_ct(     raw_dat = condition_add(cm_raw, MDONG == \"1\"),     raw_var = \"MDONG\",     tgt_var = \"CMENTPT\",     tgt_val = \"DATE OF LAST ASSESSMENT\",     id_vars = oak_id_vars()   ) %>%   # Map qualifier CMDOS as If collected value in raw_var DOS is numeric then CM.CMDOSE   assign_no_ct(     raw_dat = condition_add(cm_raw, is.numeric(DOS)),     raw_var = \"DOS\",     tgt_var = \"CMDOS\",     id_vars = oak_id_vars()   ) %>%   # Map qualifier CMDOS as If collected value in raw_var DOS is character then CM.CMDOSTXT   assign_no_ct(     raw_dat = condition_add(cm_raw, is.character(DOS)),     raw_var = \"DOS\",     tgt_var = \"CMDOSTXT\",     id_vars = oak_id_vars()   ) %>%   # Map qualifier CMDOSU as the collected value in the cm_raw dataset DOSU variable to CM.CMDOSU   assign_ct(     raw_dat = cm_raw,     raw_var = \"DOSU\",     tgt_var = \"CMDOSU\",     ct_spec = study_ct,     ct_clst = \"C71620\",     id_vars = oak_id_vars()   ) %>%   # Map qualifier CMDOSFRM as the collected value in the cm_raw dataset MDFORM variable to CM.CMDOSFRM   assign_ct(     raw_dat = cm_raw,     raw_var = \"MDFORM\",     tgt_var = \"CMDOSFRM\",     ct_spec = study_ct,     ct_clst = \"C66726\",     id_vars = oak_id_vars()   ) %>%   # Map CMROUTE as the collected value in the cm_raw dataset MDRTE variable to CM.CMROUTE   assign_ct(     raw_dat = cm_raw,     raw_var = \"MDRTE\",     tgt_var = \"CMROUTE\",     ct_spec = study_ct,     ct_clst = \"C66729\",     id_vars = oak_id_vars()   ) %>%   # Map qualifier CMPROPH as If MDPROPH == 1 then CM.CMPROPH = 'Y'   hardcode_ct(     raw_dat = condition_add(cm_raw, MDPROPH == \"1\"),     raw_var = \"MDPROPH\",     tgt_var = \"CMPROPH\",     tgt_val = \"Y\",     ct_spec = study_ct,     ct_clst = \"C66742\",     id_vars = oak_id_vars()   ) %>%   # Map CMDRG as the collected value in the cm_raw dataset CMDRG variable to CM.CMDRG   assign_no_ct(     raw_dat = cm_raw,     raw_var = \"CMDRG\",     tgt_var = \"CMDRG\",     id_vars = oak_id_vars()   ) %>%   # Map CMDRGCD as the collected value in the cm_raw dataset CMDRGCD variable to CM.CMDRGCD   assign_no_ct(     raw_dat = cm_raw,     raw_var = \"CMDRGCD\",     tgt_var = \"CMDRGCD\",     id_vars = oak_id_vars()   ) %>%   # Map CMDECOD as the collected value in the cm_raw dataset CMDECOD variable to CM.CMDECOD   assign_no_ct(     raw_dat = cm_raw,     raw_var = \"CMDECOD\",     tgt_var = \"CMDECOD\",     id_vars = oak_id_vars()   ) %>%   # Map CMPNCD as the collected value in the cm_raw dataset CMPNCD variable to CM.CMPNCD   assign_no_ct(     raw_dat = cm_raw,     raw_var = \"CMPNCD\",     tgt_var = \"CMPNCD\",     id_vars = oak_id_vars()   )"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"repeatsteps","dir":"Articles","previous_headings":"Programming workflow","what":"Repeat Map Topic and Map Rest","title":"Creating an Events SDTM domain","text":"one topic variable raw data source, additional topic variable mappings. Users can proceed next step. required one topic variable map.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"derivedvars","dir":"Articles","previous_headings":"Programming workflow","what":"Create SDTM derived variables","title":"Creating an Events SDTM domain","text":"SDTM derived variables SDTM mapping applicable records cm dataset produced previous step cam created now. example, create CMSEQ variable. mapping logic Create sequence number record CM domain.","code":"cm <- cm %>%   # The below mappings are applicable to all the records in the cm domain,   # hence can be derived using mutate statement.   dplyr::mutate(     STUDYID = \"test_study\",     DOMAIN = \"CM\",     CMCAT = \"GENERAL CONMED\",     USUBJID = paste0(\"test_study\", \"-\", cm_raw$PATNUM)   ) %>%   # derive sequence number   # derive_seq(tgt_var = \"CMSEQ\",   #            rec_vars= c(\"USUBJID\", \"CMGRPID\")) %>%   derive_study_day(     sdtm_in = .,     dm_domain = dm,     tgdt = \"CMENDTC\",     refdt = \"RFXSTDTC\",     study_day_var = \"CMENDY\"   ) %>%   derive_study_day(     sdtm_in = .,     dm_domain = dm,     tgdt = \"CMSTDTC\",     refdt = \"RFXSTDTC\",     study_day_var = \"CMSTDY\"   ) %>%   # Add code for derive Baseline flag.   dplyr::select(\"STUDYID\", \"DOMAIN\", \"USUBJID\", everything())"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/events_domain.html","id":"attributes","dir":"Articles","previous_headings":"Programming workflow","what":"Add Labels and Attributes","title":"Creating an Events SDTM domain","text":"Yet developed.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/findings_domain.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Creating an Findings SDTM domain","text":"article describes create Findings SDTM domain using {sdtm.oak} package. Examples currently presented tested context VS domain. reading article, recommended users review “Creating Events Domain” article, provides detailed explanation various concepts {sdtm.oak}, oak_id_vars, condition_add, etc. also offers guidance mapping algorithms functions use different mappings provides detailed explanation mapping algorithms functions work. article, dive directly programming provide explanation required.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/findings_domain.html","id":"programming-workflow","dir":"Articles","previous_headings":"","what":"Programming workflow","title":"Creating an Findings SDTM domain","text":"{sdtm.oak} process one raw dataset time. Similar raw datasets (example Vital Signs - Screening (OID - vs_raw), Vital Signs - Treatment (OID - vs_t_raw)) can stacked together processing. Read data Create oak_id_vars Read CT Map Topic Variable Map Rest Variables Repeat Map Topic Map Rest Repeat steps different raw datasets proceeding steps. Create SDTM derived variables Add Labels Attributes","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/findings_domain.html","id":"readdata","dir":"Articles","previous_headings":"Programming workflow","what":"Read in data","title":"Creating an Findings SDTM domain","text":"Read raw datasets environment. example, raw dataset name vs_raw. Users can read package using code:","code":"vs_raw <- read.csv(system.file(\"raw_data/vitals_raw_data.csv\",   package = \"sdtm.oak\" ))"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/findings_domain.html","id":"oakidvars","dir":"Articles","previous_headings":"Programming workflow","what":"Create oak_id_vars","title":"Creating an Findings SDTM domain","text":"Read DM domain","code":"vs_raw <- vs_raw %>%   generate_oak_id_vars(     pat_var = \"PATNUM\",     raw_src = \"vitals\"   )"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/findings_domain.html","id":"readct","dir":"Articles","previous_headings":"Programming workflow","what":"Read in CT","title":"Creating an Findings SDTM domain","text":"Controlled Terminology part SDTM specification prepared user. example, study controlled terminology name sdtm_ct.csv. Users can read package using code:","code":"study_ct <- read.csv(system.file(\"raw_data/sdtm_ct.csv\",   package = \"sdtm.oak\" ))"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/findings_domain.html","id":"maptopic","dir":"Articles","previous_headings":"Programming workflow","what":"Map Topic Variable","title":"Creating an Findings SDTM domain","text":"raw dataset multiple topic variables. Lets start first topic variable. Map topic variable SYSBP raw variable SYS_BP.","code":"# Map topic variable SYSBP and its qualifiers. vs_sysbp <-   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"SYS_BP\",     tgt_var = \"VSTESTCD\",     tgt_val = \"SYSBP\",     ct_spec = study_ct,     ct_clst = \"C66741\"   ) %>%   # Filter for records where VSTESTCD is not empty.   # Only these records need qualifier mappings.   dplyr::filter(!is.na(.data$VSTESTCD))"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/findings_domain.html","id":"maprest","dir":"Articles","previous_headings":"Programming workflow","what":"Map Rest of the Variables","title":"Creating an Findings SDTM domain","text":"Map rest variables applicable topic variable SYSBP. can include qualifiers, identifier timing variables.","code":"# Map topic variable SYSBP and its qualifiers. vs_sysbp <- vs_sysbp %>%   # Map VSTEST using hardcode_ct algorithm   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"SYS_BP\",     tgt_var = \"VSTEST\",     tgt_val = \"Systolic Blood Pressure\",     ct_spec = study_ct,     ct_clst = \"C67153\",     id_vars = oak_id_vars()   ) %>%   # Map VSORRES using assign_no_ct algorithm   assign_no_ct(     raw_dat = vs_raw,     raw_var = \"SYS_BP\",     tgt_var = \"VSORRES\",     id_vars = oak_id_vars()   ) %>%   # Map VSORRESU using hardcode_ct algorithm   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"SYS_BP\",     tgt_var = \"VSORRESU\",     tgt_val = \"mmHg\",     ct_spec = study_ct,     ct_clst = \"C66770\",     id_vars = oak_id_vars()   ) %>%   # Map VSPOS using assign_ct algorithm   assign_ct(     raw_dat = vs_raw,     raw_var = \"SUBPOS\",     tgt_var = \"VSPOS\",     ct_spec = study_ct,     ct_clst = \"C71148\",     id_vars = oak_id_vars()   )"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/findings_domain.html","id":"repeatsteps","dir":"Articles","previous_headings":"Programming workflow","what":"Repeat Map Topic and Map Rest","title":"Creating an Findings SDTM domain","text":"raw data source topic variables DIABP, PULSE, RESP, TEMP, OXYSAT, VSALL corresponding qualifiers. Repeat mapping topic qualifiers topic variable. Now topic variable qualifier mappings complete, combine datasets proceed mapping qualifiers, identifiers timing variables applicable topic variables.","code":"# Map topic variable DIABP and its qualifiers. vs_diabp <-   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"DIA_BP\",     tgt_var = \"VSTESTCD\",     tgt_val = \"DIABP\",     ct_spec = study_ct,     ct_clst = \"C66741\"   ) %>%   dplyr::filter(!is.na(.data$VSTESTCD)) %>%   # Map VSTEST using hardcode_ct algorithm   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"DIA_BP\",     tgt_var = \"VSTEST\",     tgt_val = \"Diastolic Blood Pressure\",     ct_spec = study_ct,     ct_clst = \"C67153\",     id_vars = oak_id_vars()   ) %>%   # Map VSORRES using assign_no_ct algorithm   assign_no_ct(     raw_dat = vs_raw,     raw_var = \"DIA_BP\",     tgt_var = \"VSORRES\",     id_vars = oak_id_vars()   ) %>%   # Map VSORRESU using hardcode_ct algorithm   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"DIA_BP\",     tgt_var = \"VSORRESU\",     tgt_val = \"mmHg\",     ct_spec = study_ct,     ct_clst = \"C66770\",     id_vars = oak_id_vars()   ) %>%   # Map VSPOS using assign_ct algorithm   assign_ct(     raw_dat = vs_raw,     raw_var = \"SUBPOS\",     tgt_var = \"VSPOS\",     ct_spec = study_ct,     ct_clst = \"C71148\",     id_vars = oak_id_vars()   )  # Map topic variable PULSE and its qualifiers. vs_pulse <-   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"PULSE\",     tgt_var = \"VSTESTCD\",     tgt_val = \"PULSE\",     ct_spec = study_ct,     ct_clst = \"C66741\"   ) %>%   dplyr::filter(!is.na(.data$VSTESTCD)) %>%   # Map VSTEST using hardcode_ct algorithm   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"PULSE\",     tgt_var = \"VSTEST\",     tgt_val = \"Pulse Rate\",     ct_spec = study_ct,     ct_clst = \"C67153\",     id_vars = oak_id_vars()   ) %>%   # Map VSORRES using assign_no_ct algorithm   assign_no_ct(     raw_dat = vs_raw,     raw_var = \"PULSE\",     tgt_var = \"VSORRES\",     id_vars = oak_id_vars()   ) %>%   # Map VSORRESU using hardcode_ct algorithm   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"PULSE\",     tgt_var = \"VSORRESU\",     tgt_val = \"beats/min\",     ct_spec = study_ct,     ct_clst = \"C66770\",     id_vars = oak_id_vars()   )  # Map topic variable RESP from the raw variable RESPRT and its qualifiers. vs_resp <-   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"RESPRT\",     tgt_var = \"VSTESTCD\",     tgt_val = \"RESP\",     ct_spec = study_ct,     ct_clst = \"C66741\"   ) %>%   dplyr::filter(!is.na(.data$VSTESTCD)) %>%   # Map VSTEST using hardcode_ct algorithm   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"RESPRT\",     tgt_var = \"VSTEST\",     tgt_val = \"Respiratory Rate\",     ct_spec = study_ct,     ct_clst = \"C67153\",     id_vars = oak_id_vars()   ) %>%   # Map VSORRES using assign_no_ct algorithm   assign_no_ct(     raw_dat = vs_raw,     raw_var = \"RESPRT\",     tgt_var = \"VSORRES\",     id_vars = oak_id_vars()   ) %>%   # Map VSORRESU using hardcode_ct algorithm   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"RESPRT\",     tgt_var = \"VSORRESU\",     tgt_val = \"breaths/min\",     ct_spec = study_ct,     ct_clst = \"C66770\",     id_vars = oak_id_vars()   )  # Map topic variable TEMP from raw variable TEMP and its qualifiers. vs_temp <-   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"TEMP\",     tgt_var = \"VSTESTCD\",     tgt_val = \"TEMP\",     ct_spec = study_ct,     ct_clst = \"C66741\"   ) %>%   dplyr::filter(!is.na(.data$VSTESTCD)) %>%   # Map VSTEST using hardcode_ct algorithm   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"TEMP\",     tgt_var = \"VSTEST\",     tgt_val = \"Temperature\",     ct_spec = study_ct,     ct_clst = \"C67153\",     id_vars = oak_id_vars()   ) %>%   # Map VSORRES using assign_no_ct algorithm   assign_no_ct(     raw_dat = vs_raw,     raw_var = \"TEMP\",     tgt_var = \"VSORRES\",     id_vars = oak_id_vars()   ) %>%   # Map VSORRESU using hardcode_ct algorithm   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"TEMP\",     tgt_var = \"VSORRESU\",     tgt_val = \"C\",     ct_spec = study_ct,     ct_clst = \"C66770\",     id_vars = oak_id_vars()   ) %>%   # Map VSLOC from TEMPLOC using assign_ct   assign_ct(     raw_dat = vs_raw,     raw_var = \"TEMPLOC\",     tgt_var = \"VSLOC\",     ct_spec = study_ct,     ct_clst = \"C74456\",     id_vars = oak_id_vars()   )  # Map topic variable OXYSAT from raw variable OXY_SAT and its qualifiers. vs_oxysat <-   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"OXY_SAT\",     tgt_var = \"VSTESTCD\",     tgt_val = \"OXYSAT\",     ct_spec = study_ct,     ct_clst = \"C66741\"   ) %>%   dplyr::filter(!is.na(.data$VSTESTCD)) %>%   # Map VSTEST using hardcode_ct algorithm   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"OXY_SAT\",     tgt_var = \"VSTEST\",     tgt_val = \"Oxygen Saturation\",     ct_spec = study_ct,     ct_clst = \"C67153\",     id_vars = oak_id_vars()   ) %>%   # Map VSORRES using assign_no_ct algorithm   assign_no_ct(     raw_dat = vs_raw,     raw_var = \"OXY_SAT\",     tgt_var = \"VSORRES\",     id_vars = oak_id_vars()   ) %>%   # Map VSORRESU using hardcode_ct algorithm   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"OXY_SAT\",     tgt_var = \"VSORRESU\",     tgt_val = \"%\",     ct_spec = study_ct,     ct_clst = \"C66770\",     id_vars = oak_id_vars()   ) %>%   # Map VSLAT using assign_ct from raw variable LAT   assign_ct(     raw_dat = vs_raw,     raw_var = \"LAT\",     tgt_var = \"VSLAT\",     ct_spec = study_ct,     ct_clst = \"C99073\",     id_vars = oak_id_vars()   ) %>%   # Map VSLOC using assign_ct from raw variable LOC   assign_ct(     raw_dat = vs_raw,     raw_var = \"LOC\",     tgt_var = \"VSLOC\",     ct_spec = study_ct,     ct_clst = \"C74456\",     id_vars = oak_id_vars()   )  # Map topic variable VSALL from raw variable ASMNTDN with the logic if ASMNTDN  == 1 then VSTESTCD = VSALL vs_vsall <-   hardcode_ct(     raw_dat = condition_add(vs_raw, ASMNTDN == 1L),     raw_var = \"ASMNTDN\",     tgt_var = \"VSTESTCD\",     tgt_val = \"VSALL\",     ct_spec = study_ct,     ct_clst = \"C66741\"   ) %>%   dplyr::filter(!is.na(.data$VSTESTCD)) %>%   # Map VSTEST using hardcode_ct algorithm   hardcode_ct(     raw_dat = vs_raw,     raw_var = \"ASMNTDN\",     tgt_var = \"VSTEST\",     tgt_val = \"Vital Signs\",     ct_spec = study_ct,     ct_clst = \"C67153\",     id_vars = oak_id_vars()   ) # Combine all the topic variables into a single data frame and map qualifiers # applicable to all topic variables vs <- dplyr::bind_rows(   vs_vsall, vs_sysbp, vs_diabp, vs_pulse, vs_resp,   vs_temp, vs_oxysat ) %>%   # Map qualifiers common to all topic variables   # Map VSDTC using assign_ct algorithm   assign_datetime(     raw_dat = vs_raw,     raw_var = c(\"VTLD\", \"VTLTM\"),     tgt_var = \"VSDTC\",     raw_fmt = c(list(c(\"d-m-y\", \"dd-mmm-yyyy\")), \"H:M\")   ) %>%   # Map VSTPT from TMPTC using assign_ct   assign_ct(     raw_dat = vs_raw,     raw_var = \"TMPTC\",     tgt_var = \"VSTPT\",     ct_spec = study_ct,     ct_clst = \"TPT\",     id_vars = oak_id_vars()   ) %>%   # Map VSTPTNUM from TMPTC using assign_ct   assign_ct(     raw_dat = vs_raw,     raw_var = \"TMPTC\",     tgt_var = \"VSTPTNUM\",     ct_spec = study_ct,     ct_clst = \"TPTNUM\",     id_vars = oak_id_vars()   ) %>%   # Map VISIT from INSTANCE using assign_ct   assign_ct(     raw_dat = vs_raw,     raw_var = \"INSTANCE\",     tgt_var = \"VISIT\",     ct_spec = study_ct,     ct_clst = \"VISIT\",     id_vars = oak_id_vars()   ) %>%   # Map VISITNUM from INSTANCE using assign_ct   assign_ct(     raw_dat = vs_raw,     raw_var = \"INSTANCE\",     tgt_var = \"VISITNUM\",     ct_spec = study_ct,     ct_clst = \"VISITNUM\",     id_vars = oak_id_vars()   )"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/findings_domain.html","id":"derivedvars","dir":"Articles","previous_headings":"Programming workflow","what":"Create SDTM derived variables","title":"Creating an Findings SDTM domain","text":"Create derived variables applicable topic variables.","code":"vs <- vs %>%   dplyr::mutate(     STUDYID = \"test_study\",     DOMAIN = \"VS\",     VSCAT = \"VITAL SIGNS\",     USUBJID = paste0(\"test_study\", \"-\", .data$patient_number)   ) %>%   # derive_seq(tgt_var = \"VSSEQ\",   #            rec_vars= c(\"USUBJID\", \"VSTRT\")) %>%   derive_study_day(     sdtm_in = .,     dm_domain = dm,     tgdt = \"VSDTC\",     refdt = \"RFXSTDTC\",     study_day_var = \"VSDY\"   ) %>%   dplyr::select(\"STUDYID\", \"DOMAIN\", \"USUBJID\", everything())"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/findings_domain.html","id":"attributes","dir":"Articles","previous_headings":"Programming workflow","what":"Add Labels and Attributes","title":"Creating an Findings SDTM domain","text":"Yet developed.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/iso_8601.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Converting dates, times or date-times to ISO 8601","text":"perform conversion ISO 8601 format need pass two key arguments: least one vector dates, times, date-times character type; date/time format via .format parameter instructs create_iso8601() date/time components expect. default .format parameter understands reserved characters: \"y\" year \"m\" month \"d\" day \"H\" hours \"M\" minutes \"S\" seconds Besides character vectors dates times, may also pass single vector date-times, provided adjust format:","code":"create_iso8601(\"2000 01 05\", .format = \"y m d\") #> [1] \"2000-01-05\" create_iso8601(\"22:35:05\", .format = \"H:M:S\") #> [1] \"-----T22:35:05\" create_iso8601(\"2000-01-05 22:35:05\", .format = \"y-m-d H:M:S\") #> [1] \"2000-01-05T22:35:05\""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/iso_8601.html","id":"multiple-inputs","dir":"Articles","previous_headings":"","what":"Multiple inputs","title":"Converting dates, times or date-times to ISO 8601","text":"dates times separate vectors need pass format vector: addition, like R functions take vectors input, create_iso8601() vectorized: number elements inputs match get error: can combine individual date time components coming separate inputs; contrived example year, month day together, hour, minute: .format argument must always named; otherwise, treated one inputs interpreted missing.","code":"create_iso8601(\"2000-01-05\", \"22:35:05\", .format = c(\"y-m-d\", \"H:M:S\")) #> [1] \"2000-01-05T22:35:05\" date <- c(\"2000-01-05\", \"2001-12-25\", \"1980-06-18\", \"1979-09-07\") time <- c(\"00:12:21\", \"22:35:05\", \"03:00:15\", \"07:09:00\") create_iso8601(date, time, .format = c(\"y-m-d\", \"H:M:S\")) #> [1] \"2000-01-05T00:12:21\" \"2001-12-25T22:35:05\" \"1980-06-18T03:00:15\" #> [4] \"1979-09-07T07:09:00\" date <- c(\"2000-01-05\", \"2001-12-25\", \"1980-06-18\", \"1979-09-07\") time <- \"00:12:21\" try(create_iso8601(date, time, .format = c(\"y-m-d\", \"H:M:S\"))) #> Error in create_iso8601(date, time, .format = c(\"y-m-d\", \"H:M:S\")) :  #>   All vectors in `...` must be of the same length. year <- c(\"99\", \"84\", \"00\", \"80\", \"79\", \"1944\", \"1953\") month_and_day <- c(\"jan 1\", \"apr 04\", \"mar 06\", \"jun 18\", \"sep 07\", \"sep 13\", \"sep 14\") hour <- c(\"12\", \"13\", \"05\", \"23\", \"16\", \"16\", \"19\") min <- c(\"0\", \"60\", \"59\", \"42\", \"44\", \"10\", \"13\") create_iso8601(year, month_and_day, hour, min, .format = c(\"y\", \"m d\", \"H\", \"M\")) #> [1] \"1999-01-01T12:00\" \"1984-04-04T13:60\" \"2000-03-06T05:59\" \"1980-06-18T23:42\" #> [5] \"1979-09-07T16:44\" \"1944-09-13T16:10\" \"1953-09-14T19:13\" try(create_iso8601(\"2000-01-05\", \"y-m-d\")) #> Error in create_iso8601(\"2000-01-05\", \"y-m-d\") :  #>   argument \".format\" is missing, with no default"},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/iso_8601.html","id":"format-variations","dir":"Articles","previous_headings":"","what":"Format variations","title":"Converting dates, times or date-times to ISO 8601","text":".format parameter can easily accommodate variations format inputs: Individual components may come different order, adjust format accordingly: individual characters given format taken strictly, e.g. number spaces matters: format can include regular expressions though: default, streak reserved characters treated one provided, formats equivalent:","code":"create_iso8601(\"2000-01-05\", .format = \"y-m-d\") #> [1] \"2000-01-05\" create_iso8601(\"2000 01 05\", .format = \"y m d\") #> [1] \"2000-01-05\" create_iso8601(\"2000/01/05\", .format = \"y/m/d\") #> [1] \"2000-01-05\" create_iso8601(\"2000 01 05\", .format = \"y m d\") #> [1] \"2000-01-05\" create_iso8601(\"05 01 2000\", .format = \"d m y\") #> [1] \"2000-01-05\" create_iso8601(\"01 05, 2000\", .format = \"m d, y\") #> [1] \"2000-01-05\" date <- c(\"2000 01 05\", \"2000  01 05\", \"2000 01  05\", \"2000   01   05\") create_iso8601(date, .format = \"y m d\") #> [1] \"2000-01-05\" NA           NA           NA create_iso8601(date, .format = \"y  m d\") #> [1] NA           \"2000-01-05\" NA           NA create_iso8601(date, .format = \"y m  d\") #> [1] NA           NA           \"2000-01-05\" NA create_iso8601(date, .format = \"y   m   d\") #> [1] NA           NA           NA           \"2000-01-05\" create_iso8601(date, .format = \"y\\\\s+m\\\\s+d\") #> [1] \"2000-01-05\" \"2000-01-05\" \"2000-01-05\" \"2000-01-05\" date <- c(\"2000-01-05\", \"2001-12-25\", \"1980-06-18\", \"1979-09-07\") time <- c(\"00:12:21\", \"22:35:05\", \"03:00:15\", \"07:09:00\") create_iso8601(date, time, .format = c(\"y-m-d\", \"H:M:S\")) #> [1] \"2000-01-05T00:12:21\" \"2001-12-25T22:35:05\" \"1980-06-18T03:00:15\" #> [4] \"1979-09-07T07:09:00\" create_iso8601(date, time, .format = c(\"yyyy-mm-dd\", \"HH:MM:SS\")) #> [1] \"2000-01-05T00:12:21\" \"2001-12-25T22:35:05\" \"1980-06-18T03:00:15\" #> [4] \"1979-09-07T07:09:00\" create_iso8601(date, time, .format = c(\"yyyyyyyy-m-dddddd\", \"H:MMMMM:SSSS\")) #> [1] \"2000-01-05T00:12:21\" \"2001-12-25T22:35:05\" \"1980-06-18T03:00:15\" #> [4] \"1979-09-07T07:09:00\""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/iso_8601.html","id":"multiple-alternative-formats","dir":"Articles","previous_headings":"","what":"Multiple alternative formats","title":"Converting dates, times or date-times to ISO 8601","text":"input vector contains values varying formats, single format may adequate encompass variations. situations, ’s advisable list multiple alternative formats. approach ensures format tried sequentially one matches data vector. Consider order supply formats, can significant. multiple formats potentially match, sequence determines format applied first. Note passing alternative formats, .format argument must list whose length matches number inputs.","code":"date <- c(\"2000/01/01\", \"2000-01-02\", \"2000 01 03\", \"2000/01/04\") create_iso8601(date, .format = \"y-m-d\") #> [1] NA           \"2000-01-02\" NA           NA create_iso8601(date, .format = \"y m d\") #> [1] NA           NA           \"2000-01-03\" NA create_iso8601(date, .format = \"y/m/d\") #> [1] \"2000-01-01\" NA           NA           \"2000-01-04\" create_iso8601(date, .format = list(c(\"y-m-d\", \"y m d\", \"y/m/d\"))) #> [1] \"2000-01-01\" \"2000-01-02\" \"2000-01-03\" \"2000-01-04\" create_iso8601(\"07 04 2000\", .format = list(c(\"d m y\", \"m d y\"))) #> [1] \"2000-04-07\" create_iso8601(\"07 04 2000\", .format = list(c(\"m d y\", \"d m y\"))) #> [1] \"2000-07-04\""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/iso_8601.html","id":"parsing-of-date-or-time-components","dir":"Articles","previous_headings":"","what":"Parsing of date or time components","title":"Converting dates, times or date-times to ISO 8601","text":"default, date time components parsed follows: year: either parsed two- four-digit year; month: either numeric month (single two-digit number) English abbreviated month name (e.g. Jan, Jun Dec) regardless case; month day: parsed two-digit numbers; hour minute: parsed single two-digit numbers; second: parsed single two-digit numbers optional fractional part.","code":"# Years: two-digit or four-digit numbers. years <- c(\"0\", \"1\", \"00\", \"01\", \"15\", \"30\", \"50\", \"68\", \"69\", \"80\", \"99\") create_iso8601(years, .format = \"y\") #>  [1] NA     NA     \"2000\" \"2001\" \"2015\" \"2030\" \"2050\" \"2068\" \"1969\" \"1980\" #> [11] \"1999\"  # Adjust the point where two-digits years are mapped to 2000's or 1900's. create_iso8601(years, .format = \"y\", .cutoff_2000 = 20L) #>  [1] NA     NA     \"2000\" \"2001\" \"2015\" \"1930\" \"1950\" \"1968\" \"1969\" \"1980\" #> [11] \"1999\"  # Both numeric months (two-digit only) and abbreviated months work out of the box months <- c(\"0\", \"00\", \"1\", \"01\", \"Jan\", \"jan\") create_iso8601(months, .format = \"m\") #> [1] NA     \"--00\" NA     \"--01\" \"--01\" \"--01\"  # Month days: single or two-digit numbers, anything else results in NA. create_iso8601(c(\"1\", \"01\", \"001\", \"10\", \"20\", \"31\"), .format = \"d\") #> [1] \"----01\" \"----01\" NA       \"----10\" \"----20\" \"----31\"  # Hours create_iso8601(c(\"1\", \"01\", \"001\", \"10\", \"20\", \"31\"), .format = \"H\") #> [1] \"-----T01\" \"-----T01\" NA         \"-----T10\" \"-----T20\" \"-----T31\"  # Minutes create_iso8601(c(\"1\", \"01\", \"001\", \"10\", \"20\", \"60\"), .format = \"M\") #> [1] \"-----T-:01\" \"-----T-:01\" NA           \"-----T-:10\" \"-----T-:20\" #> [6] \"-----T-:60\"  # Seconds create_iso8601(c(\"1\", \"01\", \"23.04\", \"001\", \"10\", \"20\", \"60\"), .format = \"S\") #> [1] \"-----T-:-:01\"    \"-----T-:-:01\"    \"-----T-:-:23.04\" NA                #> [5] \"-----T-:-:10\"    \"-----T-:-:20\"    \"-----T-:-:60\""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/iso_8601.html","id":"allowing-alternative-date-or-time-values","dir":"Articles","previous_headings":"","what":"Allowing alternative date or time values","title":"Converting dates, times or date-times to ISO 8601","text":"date time component values include special values, e.g. values encoding missing values, can indicate values possible alternatives parsing tolerate ; use .na argument: case achieve result using regexps:","code":"create_iso8601(\"U DEC 2019 14:00\", .format = \"d m y H:M\") #> [1] NA create_iso8601(\"U DEC 2019 14:00\", .format = \"d m y H:M\", .na = \"U\") #> [1] \"2019-12--T14:00\"  create_iso8601(\"U UNK 2019 14:00\", .format = \"d m y H:M\") #> [1] NA create_iso8601(\"U UNK 2019 14:00\", .format = \"d m y H:M\", .na = c(\"U\", \"UNK\")) #> [1] \"2019----T14:00\" create_iso8601(\"U UNK 2019 14:00\", .format = \"(d|U) (m|UNK) y H:M\") #> [1] \"2019----T14:00\""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/iso_8601.html","id":"changing-reserved-format-characters","dir":"Articles","previous_headings":"","what":"Changing reserved format characters","title":"Converting dates, times or date-times to ISO 8601","text":"might cases reserved characters — \"y\", \"m\", \"d\", \"H\", \"M\", \"S\" — might get way specifying adequate format. example, might tempted use format \"HHMM\" try parse time \"14H00M\". assume first “H” codes parsing hour, second “H” literal “H” , actually, \"HH\" taken mean parsing hours, \"MM\" parse minutes. can use function fmt_cmp() specify alternative format regexps format, replacing default characters. next example, reassign new format strings hour minute components, thus freeing \"H\" \"M\" patterns interpreted hours minutes, taken literally: Note need make sure format component regexps mutually exclusive, .e. don’t overlapping matches; otherwise create_iso8601() fail error. next example months minutes represented \"m\" format resulting ambiguous format specification.","code":"create_iso8601(\"14H00M\", .format = \"HHMM\") #> [1] NA create_iso8601(\"14H00M\", .format = \"xHwM\", .fmt_c = fmt_cmp(hour = \"x\", min = \"w\")) #> [1] \"-----T14:00\" fmt_cmp(hour = \"h\", min = \"m\") #> $sec #> [1] \"S+\" #>  #> $min #> [1] \"m\" #>  #> $hour #> [1] \"h\" #>  #> $mday #> [1] \"d+\" #>  #> $mon #> [1] \"m+\" #>  #> $year #> [1] \"y+\" #>  #> attr(,\"class\") #> [1] \"fmt_c\" try(create_iso8601(\"14H00M\", .format = \"hHmM\", .fmt_c = fmt_cmp(hour = \"h\", min = \"m\"))) #> Error in purrr::map2(dots, .format, ~parse_dttm(dttm = .x, fmt = .y, na = .na,  :  #>   ℹ In index: 1. #> Caused by error in `purrr::map()` at sdtm.oak/R/dtc_parse_dttm.R:78:3: #> ℹ In index: 1. #> Caused by error in `parse_dttm_fmt()` at sdtm.oak/R/parse_dttm_fmt.R:387:3: #> ! Patterns in `fmt_c` have overlapping matches."},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/study_sdtm_spec.html","id":"standards-metadata","dir":"Articles","previous_headings":"","what":"Standards Metadata","title":"All about Metadata","text":"standards metadata used {sdtm.oak} sourced CDISC Library sponsor MDR form documentation standards maintained. metadata provides information following: relationship Data Collection Standards (eCRF & eDT), SDTM mapping, Controlled Terminology Machine-readable standard SDTM mappings Algorithms associated metadata required SDTM automation standards study. upcoming releases {sdtm.oak}, effectively utilize standards metadata customize meet study requirements.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/study_sdtm_spec.html","id":"study-definition-metadata","dir":"Articles","previous_headings":"","what":"Study Definition Metadata","title":"All about Metadata","text":"Study Definition Metadata also referred Study Metadata. Study Definition Metadata provides information eCRF eDT data collected study. eCRF Metadata eCRF Design Metadata fetched EDC system. Metadata includes Forms Metadata: Identifier, eCRF label, Repeating format properties eCRF. Fields Metadata: Identifier, question label, datatype, properties data collection fields study. Data Dictionaries: Identifier controlled terms collected source. Visits: Name visits defined EDC. eDT Metadata eDT Metadata blueprint metadata describes data collected part external data transfer (clinical sites sponsor). includes Dataset name, label, repeating properties, etc. Variable name, datatype, label associated codelist, etc.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/articles/study_sdtm_spec.html","id":"study-sdtm-mappings-metadata-specifications","dir":"Articles","previous_headings":"","what":"Study SDTM Mappings Metadata (specifications)","title":"All about Metadata","text":"Study SDTM mappings metadata study SDTM specification. develop SDTM domains, {sdtm.oak} requires user prepare Study SDTM mappings metadata. Unlike conventional SDTM specification, includes one tab per domain defining target (SDTM domain, Variables) source (raw dataset, raw variables) SDTM mappings, SDTM spec {sdtm.oak} defines source--target relationship. source, SDTM mapping, algorithms, associated metadata defined. table presents columns SDTM mapping specification explanation.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rammprasad Ganapathy. Author, maintainer. Adam Forys. Author. Edgar Manukyan. Author. Rosemary Li. Author. Preetesh Parikh. Author. Lisa Houterloot. Author. Yogesh Gupta. Author. Omar Garcia. Author. Ramiro Magno. Author. Kamil Sijko. Author. Shiyu Chen. Author. Pattern Institute. Copyright holder, funder. F. Hoffmann-La Roche AG. Copyright holder, funder. Pfizer Inc. Copyright holder, funder. Transition Technologies Science. Copyright holder, funder.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ganapathy R, Forys , Manukyan E, Li R, Parikh P, Houterloot L, Gupta Y, Garcia O, Magno R, Sijko K, Chen S (2024). sdtm.oak: SDTM Data Transformation Engine. R package version 0.0.0.9005, https://github.com/pharmaverse/sdtm.oak, https://pharmaverse.github.io/sdtm.oak/.","code":"@Manual{,   title = {sdtm.oak: SDTM Data Transformation Engine},   author = {Rammprasad Ganapathy and Adam Forys and Edgar Manukyan and Rosemary Li and Preetesh Parikh and Lisa Houterloot and Yogesh Gupta and Omar Garcia and Ramiro Magno and Kamil Sijko and Shiyu Chen},   year = {2024},   note = {R package version 0.0.0.9005, https://github.com/pharmaverse/sdtm.oak},   url = {https://pharmaverse.github.io/sdtm.oak/}, }"},{"path":"https://pharmaverse.github.io/sdtm.oak/index.html","id":"sdtmoak-","dir":"","previous_headings":"","what":"SDTM Data Transformation Engine","title":"SDTM Data Transformation Engine","text":"EDC Data Standard agnostic solution enables pharmaceutical programming community develop SDTM datasets R. reusable algorithms concept sdtm.oak provides framework modular programming also can automate SDTM creation based standard SDTM spec.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"SDTM Data Transformation Engine","text":"can install development version sdtm.oak GitHub :","code":"# install.packages(\"remotes\") remotes::install_github(\"pharmaverse/sdtm.oak\")"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/add_problems.html","id":null,"dir":"Reference","previous_headings":"","what":"Add ISO 8601 parsing problems — add_problems","title":"Add ISO 8601 parsing problems — add_problems","text":"add_problems() annotates returned value create_iso8601() possible parsing problems. annotation consists tibble problems, one row parsing failure (see Details section).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/add_problems.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add ISO 8601 parsing problems — add_problems","text":"","code":"add_problems(x, is_problem, dtc)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/add_problems.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add ISO 8601 parsing problems — add_problems","text":"x character vector date-times ISO 8601 format; typically, output format_iso8601(). is_problem logical indicating date/time inputs associated parsing failures. dtc list character vectors dates, times date-times' components. Typically, parameter takes value passed ... create_iso8601() call.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/add_problems.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add ISO 8601 parsing problems — add_problems","text":"Either x without modification, parsing problems exist, annotated x, meaning problems attribute holds parsing issues (see Details section).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/add_problems.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add ISO 8601 parsing problems — add_problems","text":"function annotates input x, vector date-times ISO 8601 format, creating attribute named problems. attribute's value tibble parsing problems. problematic date/times indicated logical vector passed argument is_problem. attribute problems returned value contain first column named ..indicates date/time index problematic date/time x, many extra columns inputs (passed dtc). dtc named, names used name extra columns, otherwise get named sequentially like ..var1, ..var2, etc..","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/any_problems.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect problems with the parsing of date/times — any_problems","title":"Detect problems with the parsing of date/times — any_problems","text":"any_problems() takes list capture matrices (see parse_dttm()) reports parsing problems means predicate values. FALSE value indicates parsing successful TRUE value parsing failure least one inputs create_iso8601(). Note internal function used context create_iso8601() source code hence capture matrix corresponds one input create_iso8601().","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/any_problems.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect problems with the parsing of date/times — any_problems","text":"","code":"any_problems(cap_matrices, .cutoff_2000 = 68L)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/any_problems.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect problems with the parsing of date/times — any_problems","text":"cap_matrices list capture matrices sense returned value parse_dttm(). .cutoff_2000 integer value. Two-digit years smaller equal .cutoff_2000 parsed though starting 20, otherwise parsed though starting 19.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/any_problems.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect problems with the parsing of date/times — any_problems","text":"logical whose length matches number underlying date/times passed inputs create_iso8601(), .e. whose length matches number rows capture matrices cap_matrices.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_capture_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert capture matrix — assert_capture_matrix","title":"Assert capture matrix — assert_capture_matrix","text":"assert_capture_matrix() internal helper function aiding checking internal R object contains parsing results returned parse_dttm(): capture matrix. function checks capture matrix matrix contains six columns: year, mon, mday, hour, min sec.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_capture_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert capture matrix — assert_capture_matrix","text":"","code":"assert_capture_matrix(m)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_capture_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert capture matrix — assert_capture_matrix","text":"m character matrix.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_capture_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert capture matrix — assert_capture_matrix","text":"function throws error m either: character matrix; matrix whose columns (least): year, mon, mday, hour, min sec. Otherwise, returns m invisibly.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_ct_clst.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert a codelist code — assert_ct_clst","title":"Assert a codelist code — assert_ct_clst","text":"assert_ct_clst() asserts validity codelist code context controlled terminology specification.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_ct_clst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert a codelist code — assert_ct_clst","text":"","code":"assert_ct_clst(ct_spec, ct_clst, optional = FALSE)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_ct_clst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert a codelist code — assert_ct_clst","text":"ct_spec Either data frame encoding controlled terminology data set, NULL. ct_clst string -asserted codelist code, NULL. optional scalar logical, indicating whether ct_clst can NULL .","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_ct_clst.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert a codelist code — assert_ct_clst","text":"function throws error ct_clst valid codelist code given controlled terminology data set; otherwise, ct_clst returned invisibly.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_ct_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert a controlled terminology specification — assert_ct_spec","title":"Assert a controlled terminology specification — assert_ct_spec","text":"assert_ct_spec() check whether ct_spec data frame contains variables: codelist_code, collected_value, term_synonyms, term_value. addition, also check data frame empty (rows), whether columns codelist_code term_value contain NA values.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_ct_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert a controlled terminology specification — assert_ct_spec","text":"","code":"assert_ct_spec(ct_spec, optional = FALSE)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_ct_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert a controlled terminology specification — assert_ct_spec","text":"ct_spec data frame asserted valid controlled terminology data set.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_ct_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert a controlled terminology specification — assert_ct_spec","text":"function throws error ct_spec valid controlled terminology data set; otherwise, ct_spec returned invisibly.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_fmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert date time character formats — assert_dtc_fmt","title":"Assert date time character formats — assert_dtc_fmt","text":"assert_dtc_fmt() takes character vector date/time formats checks formats supported, meaning checks one formats listed column fmt dtc_formats, failing error otherwise.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_fmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert date time character formats — assert_dtc_fmt","text":"","code":"assert_dtc_fmt(fmt)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_fmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert date time character formats — assert_dtc_fmt","text":"fmt character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_format.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert dtc format — assert_dtc_format","title":"Assert dtc format — assert_dtc_format","text":"assert_dtc_format() internal helper function aiding checking .format parameter create_iso8601().","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert dtc format — assert_dtc_format","text":"","code":"assert_dtc_format(.format)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert dtc format — assert_dtc_format","text":".format argument create_iso8601()'s .format parameter.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assert_dtc_format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert dtc format — assert_dtc_format","text":"function throws error .format either: character vector formats permitted assert_dtc_fmt(); list character vectors formats permitted assert_dtc_fmt(). Otherwise, returns .format invisibly.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assign.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive an SDTM variable — assign_no_ct","title":"Derive an SDTM variable — assign_no_ct","text":"assign_no_ct() maps variable raw dataset target SDTM variable terminology restrictions. assign_ct() maps variable raw dataset target SDTM variable following controlled terminology recoding.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive an SDTM variable — assign_no_ct","text":"","code":"assign_no_ct(   tgt_dat = NULL,   tgt_var,   raw_dat,   raw_var,   id_vars = oak_id_vars() )  assign_ct(   tgt_dat = NULL,   tgt_var,   raw_dat,   raw_var,   ct_spec,   ct_clst,   id_vars = oak_id_vars() )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive an SDTM variable — assign_no_ct","text":"tgt_dat Target dataset: data frame merged raw_dat variables indicated id_vars. parameter optional, see section Value output changes depending argument value. tgt_var target SDTM variable: single string indicating name variable derived. raw_dat raw dataset (dataframe); must include variables passed id_vars raw_var. raw_var raw variable: single string indicating name raw variable raw_dat. id_vars Key variables used join raw dataset (raw_dat) target data set (raw_dat). ct_spec Study controlled terminology specification: dataframe minimal set columns, see ct_spec_vars() details. ct_clst codelist code indicating subset controlled terminology apply derivation.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive an SDTM variable — assign_no_ct","text":"returned data set depends value tgt_dat: target dataset supplied, meaning tgt_dat defaults NULL, returned data set raw_dat, selected variables indicated id_vars, new extra column: derived variable, indicated tgt_var. target dataset provided, merged raw data set raw_dat variables indicated id_vars, new column: derived variable, indicated tgt_var.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assign.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Derive an SDTM variable — assign_no_ct","text":"","code":"md1 <-   tibble::tibble(     oak_id = 1:14,     raw_source = \"MD1\",     patient_number = 101:114,     MDIND = c(       \"NAUSEA\", \"NAUSEA\", \"ANEMIA\", \"NAUSEA\", \"PYREXIA\",       \"VOMITINGS\", \"DIARHHEA\", \"COLD\",       \"FEVER\", \"LEG PAIN\", \"FEVER\", \"COLD\", \"COLD\", \"PAIN\"     )   )  assign_no_ct(   tgt_var = \"CMINDC\",   raw_dat = md1,   raw_var = \"MDIND\" ) #> # A tibble: 14 × 4 #>    oak_id raw_source patient_number CMINDC    #>     <int> <chr>               <int> <chr>     #>  1      1 MD1                   101 NAUSEA    #>  2      2 MD1                   102 NAUSEA    #>  3      3 MD1                   103 ANEMIA    #>  4      4 MD1                   104 NAUSEA    #>  5      5 MD1                   105 PYREXIA   #>  6      6 MD1                   106 VOMITINGS #>  7      7 MD1                   107 DIARHHEA  #>  8      8 MD1                   108 COLD      #>  9      9 MD1                   109 FEVER     #> 10     10 MD1                   110 LEG PAIN  #> 11     11 MD1                   111 FEVER     #> 12     12 MD1                   112 COLD      #> 13     13 MD1                   113 COLD      #> 14     14 MD1                   114 PAIN       cm_inter <-   tibble::tibble(     oak_id = 1:14,     raw_source = \"MD1\",     patient_number = 101:114,     CMTRT = c(       \"BABY ASPIRIN\",       \"CORTISPORIN\",       \"ASPIRIN\",       \"DIPHENHYDRAMINE HCL\",       \"PARCETEMOL\",       \"VOMIKIND\",       \"ZENFLOX OZ\",       \"AMITRYPTYLINE\",       \"BENADRYL\",       \"DIPHENHYDRAMINE HYDROCHLORIDE\",       \"TETRACYCLINE\",       \"BENADRYL\",       \"SOMINEX\",       \"ZQUILL\"     ),     CMROUTE = c(       \"ORAL\",       \"ORAL\",       NA,       \"ORAL\",       \"ORAL\",       \"ORAL\",       \"INTRAMUSCULAR\",       \"INTRA-ARTERIAL\",       NA,       \"NON-STANDARD\",       \"RANDOM_VALUE\",       \"INTRA-ARTICULAR\",       \"TRANSDERMAL\",       \"OPHTHALMIC\"     )   )  # Controlled terminology specification (ct_spec <- read_ct_spec_example(\"ct-01-cm\")) #> # A tibble: 33 × 8 #>    codelist_code term_code CodedData term_value collected_value     #>    <chr>         <chr>     <chr>     <chr>      <chr>               #>  1 C71113        C25473    QD        QD         QD (Every Day)      #>  2 C71113        C64496    BID       BID        BID (Twice a Day)   #>  3 C71113        C64499    PRN       PRN        PRN (As Needed)     #>  4 C71113        C64516    Q2H       Q2H        Q2H (Every 2 Hours) #>  5 C71113        C64530    QID       QID        QID (4 Times a Day) #>  6 C66726        C25158    CAPSULE   CAPSULE    Capsule             #>  7 C66726        C25394    PILL      PILL       Pill                #>  8 C66726        C29167    LOTION    LOTION     Lotion              #>  9 C66726        C42887    AEROSOL   AEROSOL    Aerosol             #> 10 C66726        C42944    INHALANT  INHALANT   Inhalant            #> # ℹ 23 more rows #> # ℹ 3 more variables: term_preferred_term <chr>, term_synonyms <chr>, #> #   raw_codelist <chr>  assign_ct(   tgt_dat = cm_inter,   tgt_var = \"CMINDC\",   raw_dat = md1,   raw_var = \"MDIND\",   ct_spec = ct_spec,   ct_clst = \"C66729\" ) #> # A tibble: 14 × 6 #>    oak_id raw_source patient_number CMTRT                         CMROUTE CMINDC #>     <int> <chr>               <int> <chr>                         <chr>   <chr>  #>  1      1 MD1                   101 BABY ASPIRIN                  ORAL    NAUSEA #>  2      2 MD1                   102 CORTISPORIN                   ORAL    NAUSEA #>  3      3 MD1                   103 ASPIRIN                       NA      ANEMIA #>  4      4 MD1                   104 DIPHENHYDRAMINE HCL           ORAL    NAUSEA #>  5      5 MD1                   105 PARCETEMOL                    ORAL    PYREX… #>  6      6 MD1                   106 VOMIKIND                      ORAL    VOMIT… #>  7      7 MD1                   107 ZENFLOX OZ                    INTRAM… DIARH… #>  8      8 MD1                   108 AMITRYPTYLINE                 INTRA-… COLD   #>  9      9 MD1                   109 BENADRYL                      NA      FEVER  #> 10     10 MD1                   110 DIPHENHYDRAMINE HYDROCHLORIDE NON-ST… LEG P… #> 11     11 MD1                   111 TETRACYCLINE                  RANDOM… FEVER  #> 12     12 MD1                   112 BENADRYL                      INTRA-… COLD   #> 13     13 MD1                   113 SOMINEX                       TRANSD… COLD   #> 14     14 MD1                   114 ZQUILL                        OPHTHA… PAIN"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assign_datetime.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive an ISO8601 date-time variable — assign_datetime","title":"Derive an ISO8601 date-time variable — assign_datetime","text":"assign_datetime() maps one variables date/time components raw dataset target SDTM variable following ISO8601 format.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assign_datetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive an ISO8601 date-time variable — assign_datetime","text":"","code":"assign_datetime(   tgt_dat = NULL,   tgt_var,   raw_dat,   raw_var,   raw_fmt,   raw_unk = c(\"UN\", \"UNK\"),   id_vars = oak_id_vars(),   .warn = TRUE )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assign_datetime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive an ISO8601 date-time variable — assign_datetime","text":"tgt_dat Target dataset: data frame merged raw_dat variables indicated id_vars. parameter optional, see section Value output changes depending argument value. tgt_var target SDTM variable: single string indicating name variable derived. raw_dat raw dataset (dataframe); must include variables passed id_vars raw_var. raw_var raw variable(s): character vector indicating name(s) raw variable(s) raw_dat date time components parsed ISO8601 format variable tgt_var. raw_fmt date/time parsing format. Either character vector list character vectors. character vector passed element taken parsing format variable indicated raw_var. list provided, element must character vector formats. first vector formats used parsing first variable raw_var, . raw_unk character vector string literals regarded missing values parsing. id_vars Key variables used join raw dataset (raw_dat) target data set (tgt_dat). .warn Whether warn parsing failures.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assign_datetime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive an ISO8601 date-time variable — assign_datetime","text":"returned data set depends value tgt_dat: target dataset supplied, meaning tgt_dat defaults NULL, returned data set raw_dat, selected variables indicated id_vars, new extra column: derived variable, indicated tgt_var. target dataset provided, merged raw data set raw_dat variables indicated id_vars, new column: derived variable, indicated tgt_var.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/assign_datetime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Derive an ISO8601 date-time variable — assign_datetime","text":"","code":"# `md1`: an example raw data set. md1 <-   tibble::tribble(     ~oak_id, ~raw_source, ~patient_number, ~MDBDR,        ~MDEDR,        ~MDETM,     1L,      \"MD1\",       375,             NA,            NA,            NA,     2L,      \"MD1\",       375,             \"15-Sep-20\",   NA,            NA,     3L,      \"MD1\",       376,             \"17-Feb-21\",   \"17-Feb-21\",   NA,     4L,      \"MD1\",       377,             \"4-Oct-20\",    NA,            NA,     5L,      \"MD1\",       377,             \"20-Jan-20\",   \"20-Jan-20\",   \"10:00:00\",     6L,      \"MD1\",       377,             \"UN-UNK-2019\", \"UN-UNK-2019\", NA,     7L,      \"MD1\",       377,             \"20-UNK-2019\", \"20-UNK-2019\", NA,     8L,      \"MD1\",       378,             \"UN-UNK-2020\", \"UN-UNK-2020\", NA,     9L,      \"MD1\",       378,             \"26-Jan-20\",   \"26-Jan-20\",   \"07:00:00\",     10L,     \"MD1\",       378,             \"28-Jan-20\",   \"1-Feb-20\",    NA,     11L,     \"MD1\",       378,             \"12-Feb-20\",   \"18-Feb-20\",   NA,     12L,     \"MD1\",       379,             \"10-UNK-2020\", \"20-UNK-2020\", NA,     13L,     \"MD1\",       379,             NA,            NA,            NA,     14L,     \"MD1\",       379,             NA,            \"17-Feb-20\",   NA   )  # Using the raw data set `md1`, derive the variable CMSTDTC from MDBDR using # the parsing format (`raw_fmt`) `\"d-m-y\"` (day-month-year), while allowing # for the presence of special date component values (e.g. `\"UN\"` or `\"UNK\"`), # indicating that these values are missing/unknown (unk). cm1 <-   assign_datetime(     tgt_var = \"CMSTDTC\",     raw_dat = md1,     raw_var = \"MDBDR\",     raw_fmt = \"d-m-y\",     raw_unk = c(\"UN\", \"UNK\")   )  cm1 #> # A tibble: 14 × 4 #>    oak_id raw_source patient_number CMSTDTC    #>     <int> <chr>               <dbl> <iso8601>  #>  1      1 MD1                   375 NA         #>  2      2 MD1                   375 2020-09-15 #>  3      3 MD1                   376 2021-02-17 #>  4      4 MD1                   377 2020-10-04 #>  5      5 MD1                   377 2020-01-20 #>  6      6 MD1                   377 2019       #>  7      7 MD1                   377 2019---20  #>  8      8 MD1                   378 2020       #>  9      9 MD1                   378 2020-01-26 #> 10     10 MD1                   378 2020-01-28 #> 11     11 MD1                   378 2020-02-12 #> 12     12 MD1                   379 2020---10  #> 13     13 MD1                   379 NA         #> 14     14 MD1                   379 NA          # Inspect parsing failures associated with derivation of CMSTDTC. problems(cm1$CMSTDTC) #> # A tibble: 3 × 2 #>     ..i MDBDR #>   <int> <chr> #> 1     1 NA    #> 2    13 NA    #> 3    14 NA     # `cm_inter`: an example target data set. cm_inter <-   tibble::tibble(     oak_id = 1L:14L,     raw_source = \"MD1\",     patient_number = c(       375, 375, 376, 377, 377, 377, 377, 378,       378, 378, 378, 379, 379, 379     ),     CMTRT = c(       \"BABY ASPIRIN\",       \"CORTISPORIN\",       \"ASPIRIN\",       \"DIPHENHYDRAMINE HCL\",       \"PARCETEMOL\",       \"VOMIKIND\",       \"ZENFLOX OZ\",       \"AMITRYPTYLINE\",       \"BENADRYL\",       \"DIPHENHYDRAMINE HYDROCHLORIDE\",       \"TETRACYCLINE\",       \"BENADRYL\",       \"SOMINEX\",       \"ZQUILL\"     ),     CMINDC = c(       \"NA\",       \"NAUSEA\",       \"ANEMIA\",       \"NAUSEA\",       \"PYREXIA\",       \"VOMITINGS\",       \"DIARHHEA\",       \"COLD\",       \"FEVER\",       \"LEG PAIN\",       \"FEVER\",       \"COLD\",       \"COLD\",       \"PAIN\"     )   )  # Same derivation as above but now involving the merging with the target # data set `cm_inter`. cm2 <-   assign_datetime(     tgt_dat = cm_inter,     tgt_var = \"CMSTDTC\",     raw_dat = md1,     raw_var = \"MDBDR\",     raw_fmt = \"d-m-y\"   )  cm2 #> # A tibble: 14 × 6 #>    oak_id raw_source patient_number CMTRT                         CMINDC CMSTDTC #>     <int> <chr>               <dbl> <chr>                         <chr>  <iso86> #>  1      1 MD1                   375 BABY ASPIRIN                  NA     NA    … #>  2      2 MD1                   375 CORTISPORIN                   NAUSEA 2020-0… #>  3      3 MD1                   376 ASPIRIN                       ANEMIA 2021-0… #>  4      4 MD1                   377 DIPHENHYDRAMINE HCL           NAUSEA 2020-1… #>  5      5 MD1                   377 PARCETEMOL                    PYREX… 2020-0… #>  6      6 MD1                   377 VOMIKIND                      VOMIT… 2019  … #>  7      7 MD1                   377 ZENFLOX OZ                    DIARH… 2019--… #>  8      8 MD1                   378 AMITRYPTYLINE                 COLD   2020  … #>  9      9 MD1                   378 BENADRYL                      FEVER  2020-0… #> 10     10 MD1                   378 DIPHENHYDRAMINE HYDROCHLORIDE LEG P… 2020-0… #> 11     11 MD1                   378 TETRACYCLINE                  FEVER  2020-0… #> 12     12 MD1                   379 BENADRYL                      COLD   2020--… #> 13     13 MD1                   379 SOMINEX                       COLD   NA    … #> 14     14 MD1                   379 ZQUILL                        PAIN   NA    …  # Inspect parsing failures associated with derivation of CMSTDTC. problems(cm2$CMSTDTC) #> # A tibble: 3 × 2 #>     ..i MDBDR #>   <int> <chr> #> 1     1 NA    #> 2    13 NA    #> 3    14 NA     # Derive CMSTDTC using both MDEDR and MDETM variables. # Note that the format `\"d-m-y\"` is used for parsing MDEDR and `\"H:M:S\"` for # MDETM (correspondence is by positional matching). cm3 <-   assign_datetime(     tgt_var = \"CMSTDTC\",     raw_dat = md1,     raw_var = c(\"MDEDR\", \"MDETM\"),     raw_fmt = c(\"d-m-y\", \"H:M:S\"),     raw_unk = c(\"UN\", \"UNK\")   )  cm3 #> # A tibble: 14 × 4 #>    oak_id raw_source patient_number CMSTDTC             #>     <int> <chr>               <dbl> <iso8601>           #>  1      1 MD1                   375 NA                  #>  2      2 MD1                   375 NA                  #>  3      3 MD1                   376 2021-02-17          #>  4      4 MD1                   377 NA                  #>  5      5 MD1                   377 2020-01-20T10:00:00 #>  6      6 MD1                   377 2019                #>  7      7 MD1                   377 2019---20           #>  8      8 MD1                   378 2020                #>  9      9 MD1                   378 2020-01-26T07:00:00 #> 10     10 MD1                   378 2020-02-01          #> 11     11 MD1                   378 2020-02-18          #> 12     12 MD1                   379 2020---20           #> 13     13 MD1                   379 NA                  #> 14     14 MD1                   379 2020-02-17           # Inspect parsing failures associated with derivation of CMSTDTC. problems(cm3$CMSTDTC) #> # A tibble: 12 × 3 #>      ..i MDEDR       MDETM #>    <int> <chr>       <chr> #>  1     1 NA          NA    #>  2     2 NA          NA    #>  3     3 17-Feb-21   NA    #>  4     4 NA          NA    #>  5     6 UN-UNK-2019 NA    #>  6     7 20-UNK-2019 NA    #>  7     8 UN-UNK-2020 NA    #>  8    10 1-Feb-20    NA    #>  9    11 18-Feb-20   NA    #> 10    12 20-UNK-2020 NA    #> 11    13 NA          NA    #> 12    14 17-Feb-20   NA"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/clear_cache.html","id":null,"dir":"Reference","previous_headings":"","what":"Clear {sdtm.oak} cache of memoised functions — clear_cache","title":"Clear {sdtm.oak} cache of memoised functions — clear_cache","text":"{sdtm.oak} functions results cached runtime efficiency. Use function reset cache. Memoised functions: ct_mappings()","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/clear_cache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clear {sdtm.oak} cache of memoised functions — clear_cache","text":"","code":"clear_cache()"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/clear_cache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clear {sdtm.oak} cache of memoised functions — clear_cache","text":"Returns logical value, indicating whether resetting cache successful (TRUE) (FALSE).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/clear_cache.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clear {sdtm.oak} cache of memoised functions — clear_cache","text":"","code":"clear_cache() #> [1] TRUE"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/coalesce_capture_matrices.html","id":null,"dir":"Reference","previous_headings":"","what":"Coalesce capture matrices — coalesce_capture_matrices","title":"Coalesce capture matrices — coalesce_capture_matrices","text":"coalesce_capture_matrices() combines several capture matrices one. argument ... capture matrix sense output complete_capture_matrix(), meaning character matrix six columns whose names : year, mon, mday, hour, min sec.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/coalesce_capture_matrices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coalesce capture matrices — coalesce_capture_matrices","text":"","code":"coalesce_capture_matrices(...)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/coalesce_capture_matrices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coalesce capture matrices — coalesce_capture_matrices","text":"... sequence capture matrices.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/coalesce_capture_matrices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coalesce capture matrices — coalesce_capture_matrices","text":"single capture matrix whose values coalesced sense coalesce().","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/complete_capture_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Complete a capture matrix — complete_capture_matrix","title":"Complete a capture matrix — complete_capture_matrix","text":"complete_capture_matrix() completes missing, , columns capture matrix.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/complete_capture_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Complete a capture matrix — complete_capture_matrix","text":"","code":"complete_capture_matrix(m)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/complete_capture_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Complete a capture matrix — complete_capture_matrix","text":"m character matrix might missing one following columns: year, mon, mday, hour, min sec.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/complete_capture_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Complete a capture matrix — complete_capture_matrix","text":"character matrix contains columns year, mon, mday, hour, min sec. existing columns dropped.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/condition_add.html","id":null,"dir":"Reference","previous_headings":"","what":"Add filtering tags to a data set — condition_add","title":"Add filtering tags to a data set — condition_add","text":"condition_add() tags records data set, indicating rows match specified conditions, resulting conditioned data frame. Learn integrate conditioned data frames SDTM domain derivation vignette(\"cnd_df\").","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/condition_add.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add filtering tags to a data set — condition_add","text":"","code":"condition_add(dat, ..., .na = NA, .dat2 = rlang::env())"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/condition_add.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add filtering tags to a data set — condition_add","text":"dat data frame. ... Conditions filter data frame. .na Return value used conditions evaluate NA. .dat2 optional environment look variables involved logical expression passed .... data frame list can also passed coerced environment internally.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/condition_add.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add filtering tags to a data set — condition_add","text":"conditioned data frame, meaning tibble additional class cnd_df logical vector attribute indicating matching rows.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/condition_add.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add filtering tags to a data set — condition_add","text":"","code":"(df <- tibble::tibble(x = 1L:3L, y = letters[x])) #> # A tibble: 3 × 2 #>       x y     #>   <int> <chr> #> 1     1 a     #> 2     2 b     #> 3     3 c      # Mark rows for which `x` greater than `1` (cnd_df <- condition_add(dat = df, x > 1L)) #> # A tibble:  3 × 2 #> # Cond. tbl: 2/1/0 #>         x y     #>     <int> <chr> #> 1 F     1 a     #> 2 T     2 b     #> 3 T     3 c"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/contains_oak_id_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Does a vector contain the raw dataset key variables? — contains_oak_id_vars","title":"Does a vector contain the raw dataset key variables? — contains_oak_id_vars","text":"contains_oak_id_vars() evaluates whether character vector x contains raw dataset key variable names, .e. called Oak identifier variables --- defined return value oak_id_vars().","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/contains_oak_id_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does a vector contain the raw dataset key variables? — contains_oak_id_vars","text":"","code":"contains_oak_id_vars(x)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/contains_oak_id_vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does a vector contain the raw dataset key variables? — contains_oak_id_vars","text":"x character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/contains_oak_id_vars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Does a vector contain the raw dataset key variables? — contains_oak_id_vars","text":"logical scalar value.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/create_iso8601.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert date or time collected values to ISO 8601 — create_iso8601","title":"Convert date or time collected values to ISO 8601 — create_iso8601","text":"create_iso8601() converts vectors dates, times date-times ISO 8601 format. Learn vignette(\"iso_8601\").","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/create_iso8601.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert date or time collected values to ISO 8601 — create_iso8601","text":"","code":"create_iso8601(   ...,   .format,   .fmt_c = fmt_cmp(),   .na = NULL,   .cutoff_2000 = 68L,   .check_format = FALSE,   .warn = TRUE )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/create_iso8601.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert date or time collected values to ISO 8601 — create_iso8601","text":"... Character vectors dates, times date-times' components. .format Parsing format(s). Either character vector list character vectors. character vector passed element taken parsing format vector passed .... list provided, element must character vector formats. first vector formats used parsing first vector passed ..., . .fmt_c list regexps use parsing .format. Use fmt_cmp() create object pass argument parameter. .na character vector string literals regarded missing values parsing. .cutoff_2000 integer value. Two-digit years smaller equal .cutoff_2000 parsed though starting 20, otherwise parsed though starting 19. .check_format Whether check formats passed .format, meaning check selection validated formats dtc_formats; permissible interpretation formats. .warn Whether warn parsing failures.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/create_iso8601.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert date or time collected values to ISO 8601 — create_iso8601","text":"","code":"# Converting dates create_iso8601(c(\"2020-01-01\", \"20200102\"), .format = \"y-m-d\") #> [1] \"2020-01-01\" NA           create_iso8601(c(\"2020-01-01\", \"20200102\"), .format = \"ymd\") #> [1] NA           \"2020-01-02\" create_iso8601(c(\"2020-01-01\", \"20200102\"), .format = list(c(\"y-m-d\", \"ymd\"))) #> [1] \"2020-01-01\" \"2020-01-02\"  # Two-digit years are supported create_iso8601(c(\"20-01-01\", \"200101\"), .format = list(c(\"y-m-d\", \"ymd\"))) #> [1] \"2020-01-01\" \"2020-01-01\"  # `.cutoff_2000` sets the cutoff for two-digit to four-digit year conversion # Default is at 68. create_iso8601(c(\"67-01-01\", \"68-01-01\", \"69-01-01\"), .format = \"y-m-d\") #> [1] \"2067-01-01\" \"2068-01-01\" \"1969-01-01\"  # Change it to 80. create_iso8601(c(\"79-01-01\", \"80-01-01\", \"81-01-01\"), .format = \"y-m-d\", .cutoff_2000 = 80) #> [1] \"2079-01-01\" \"2080-01-01\" \"1981-01-01\"  # Converting times create_iso8601(\"15:10\", .format = \"HH:MM\") #> [1] \"-----T15:10\" create_iso8601(\"2:10\", .format = \"HH:MM\") #> [1] \"-----T02:10\" create_iso8601(\"2:1\", .format = \"HH:MM\") #> [1] \"-----T02:01\" create_iso8601(\"02:01:56\", .format = \"HH:MM:SS\") #> [1] \"-----T02:01:56\" create_iso8601(\"020156.5\", .format = \"HHMMSS\") #> [1] \"-----T02:01:56.5\"  # Converting date-times create_iso8601(\"12 NOV 202015:15\", .format = \"dd mmm yyyyHH:MM\") #> [1] \"2020-11-12T15:15\"  # Indicate allowed missing values to make the parsing pass create_iso8601(\"U DEC 201914:00\", .format = \"dd mmm yyyyHH:MM\") #> [1] NA create_iso8601(\"U DEC 201914:00\", .format = \"dd mmm yyyyHH:MM\", .na = \"U\") #> [1] \"2019-12--T14:00\"  create_iso8601(\"NOV 2020\", .format = \"m y\") #> [1] \"2020-11\" create_iso8601(c(\"MAR 2019\", \"MaR 2020\", \"mar 2021\"), .format = \"m y\") #> [1] \"2019-03\" \"2020-03\" \"2021-03\"  create_iso8601(\"2019-04-041045-\", .format = \"yyyy-mm-ddHHMM-\") #> [1] \"2019-04-04T10:45\"  create_iso8601(\"20200507null\", .format = \"ymd(HH:MM:SS)\") #> [1] NA create_iso8601(\"20200507null\", .format = \"ymd((HH:MM:SS)|null)\") #> [1] \"2020-05-07\"  # Fractional seconds create_iso8601(\"2019-120602:20:13.1230001\", .format = \"y-mdH:M:S\") #> [1] \"2019-12-06T02:20:13.1230001\"  # Use different reserved characters in the format specification # Here we change \"H\" to \"x\" and \"M\" to \"w\", for hour and minute, respectively. create_iso8601(\"14H00M\", .format = \"HHMM\") #> [1] NA create_iso8601(\"14H00M\", .format = \"xHwM\", .fmt_c = fmt_cmp(hour = \"x\", min = \"w\")) #> [1] \"-----T14:00\"  # Alternative formats with unknown values datetimes <- c(\"UN UNK 201914:00\", \"UN JAN 2021\") format <- list(c(\"dd mmm yyyy\", \"dd mmm yyyyHH:MM\")) create_iso8601(datetimes, .format = format, .na = c(\"UN\", \"UNK\")) #> [1] \"2019----T14:00\" \"2021-01\"         # Dates and times may come in many format variations fmt <- \"dd MMM yyyy HH nn ss\" fmt_cmp <- fmt_cmp(mon = \"MMM\", min = \"nn\", sec = \"ss\") create_iso8601(\"05 feb 1985 12 55 02\", .format = fmt, .fmt_c = fmt_cmp) #> [1] \"1985-02-05T12:55:02\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Recode according to controlled terminology — ct_map","title":"Recode according to controlled terminology — ct_map","text":"ct_map() recodes vector following controlled terminology.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recode according to controlled terminology — ct_map","text":"","code":"ct_map(   x,   ct_spec = NULL,   ct_clst = NULL,   from = ct_spec_vars(\"from\"),   to = ct_spec_vars(\"to\") )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recode according to controlled terminology — ct_map","text":"x character vector terms recoded following controlled terminology. ct_spec tibble providing controlled terminology specification. ct_clst character vector indicating set possible controlled terminology codelists codes used recoding. default (NULL) codelists available ct_spec used. character vector column names indicating variables containing values matched terminology recoding. single string indicating column whose values recoded .","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recode according to controlled terminology — ct_map","text":"character vector terminology recoded values x. match found controlled terminology spec provided ct_spec, x values returned uppercase. ct_spec provided x returned unchanged.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recode according to controlled terminology — ct_map","text":"","code":"# A few example terms. terms <-   c(     \"/day\",     \"Yes\",     \"Unknown\",     \"Prior\",     \"Every 2 hours\",     \"Percentage\",     \"International Unit\"   )  # Load a controlled terminology example (ct_spec <- read_ct_spec_example(\"ct-01-cm\")) #> # A tibble: 33 × 8 #>    codelist_code term_code CodedData term_value collected_value     #>    <chr>         <chr>     <chr>     <chr>      <chr>               #>  1 C71113        C25473    QD        QD         QD (Every Day)      #>  2 C71113        C64496    BID       BID        BID (Twice a Day)   #>  3 C71113        C64499    PRN       PRN        PRN (As Needed)     #>  4 C71113        C64516    Q2H       Q2H        Q2H (Every 2 Hours) #>  5 C71113        C64530    QID       QID        QID (4 Times a Day) #>  6 C66726        C25158    CAPSULE   CAPSULE    Capsule             #>  7 C66726        C25394    PILL      PILL       Pill                #>  8 C66726        C29167    LOTION    LOTION     Lotion              #>  9 C66726        C42887    AEROSOL   AEROSOL    Aerosol             #> 10 C66726        C42944    INHALANT  INHALANT   Inhalant            #> # ℹ 23 more rows #> # ℹ 3 more variables: term_preferred_term <chr>, term_synonyms <chr>, #> #   raw_codelist <chr>  # Use all possible matching terms in the controlled terminology. ct_map(x = terms, ct_spec = ct_spec) #> [1] \"QD\"      \"Y\"       \"UNKNOWN\" \"BEFORE\"  \"Q2H\"     \"%\"       \"IU\"       # Note that if the controlled terminology mapping is restricted to a codelist # code, e.g. C71113, then only `\"/day\"` and `\"Every 2 hours\"` get mapped to # `\"QD\"` and `\"Q2H\"`, respectively; remaining terms won't match given the # codelist code restriction, and will be mapped to an uppercase version of # the original terms. ct_map(x = terms, ct_spec = ct_spec, ct_clst = \"C71113\") #> [1] \"QD\"                 \"YES\"                \"UNKNOWN\"            #> [4] \"PRIOR\"              \"Q2H\"                \"PERCENTAGE\"         #> [7] \"INTERNATIONAL UNIT\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_mappings.html","id":null,"dir":"Reference","previous_headings":"","what":"Controlled terminology mappings — ct_mappings","title":"Controlled terminology mappings — ct_mappings","text":"ct_mappings() takes controlled terminology specification returns mappings form tibble long format, .e. recoding values column column values, one mapping per row. resulting mappings unique, .e. values duplicated two columns, first column indicated takes precedence, mapping retained controlled terminology map.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_mappings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Controlled terminology mappings — ct_mappings","text":"","code":"ct_mappings(ct_spec, from = ct_spec_vars(\"from\"), to = ct_spec_vars(\"to\"))"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_mappings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Controlled terminology mappings — ct_mappings","text":"ct_spec Controlled terminology specification tibble. row mapped controlled term. Controlled terms expected column indicated to_col. character vector column names indicating variables containing values recoded. single string indicating column whose values recoded .","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_mappings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Controlled terminology mappings — ct_mappings","text":"tibble two columns, , indicating mapping values, one per row.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_spec_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the path to an example controlled terminology file — ct_spec_example","title":"Find the path to an example controlled terminology file — ct_spec_example","text":"ct_spec_example() resolves local path example controlled terminology file.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_spec_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the path to an example controlled terminology file — ct_spec_example","text":"","code":"ct_spec_example(example)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_spec_example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the path to an example controlled terminology file — ct_spec_example","text":"example string either basename, file name, relative path controlled terminology file bundled {stdm.oak}, see examples.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_spec_example.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the path to an example controlled terminology file — ct_spec_example","text":"local path example file example supplied, character vector example file names.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_spec_example.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the path to an example controlled terminology file — ct_spec_example","text":"","code":"# Get the local path to controlled terminology example file 01 # Using the basename only: ct_spec_example(\"ct-01-cm\") #> [1] \"/renv/lib/R-4.3/x86_64-pc-linux-gnu/sdtm.oak/ct/ct-01-cm.csv\"  # Using the file name: ct_spec_example(\"ct-01-cm.csv\") #> [1] \"/renv/lib/R-4.3/x86_64-pc-linux-gnu/sdtm.oak/ct/ct-01-cm.csv\"  # Using the relative path: ct_spec_example(\"ct/ct-01-cm.csv\") #> [1] \"/renv/lib/R-4.3/x86_64-pc-linux-gnu/sdtm.oak/ct/ct-01-cm.csv\"  # If no example is provided it returns a vector of possible choices. ct_spec_example() #> [1] \"ct-01-cm.csv\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_spec_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Controlled terminology variables — ct_spec_vars","title":"Controlled terminology variables — ct_spec_vars","text":"ct_spec_vars() returns mandatory variables present data set representing controlled terminology. default, returns required variables. subset variables used matching terms needed, request subset variables passing argument value \"\". mapping-variable requested, simply pass \"\". codelist code variable name needed pass \"ct_clst\".","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_spec_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Controlled terminology variables — ct_spec_vars","text":"","code":"ct_spec_vars(set = c(\"all\", \"ct_clst\", \"from\", \"to\"))"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ct_spec_vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Controlled terminology variables — ct_spec_vars","text":"set scalar character (string), one : \"\" (default), \"ct_clst\", \"\" \"\".","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ctl_new_rowid_pillar.cnd_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditioned tibble pillar print method — ctl_new_rowid_pillar.cnd_df","title":"Conditioned tibble pillar print method — ctl_new_rowid_pillar.cnd_df","text":"Conditioned tibble pillar print method","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ctl_new_rowid_pillar.cnd_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditioned tibble pillar print method — ctl_new_rowid_pillar.cnd_df","text":"","code":"# S3 method for cnd_df ctl_new_rowid_pillar(controller, x, width, ...)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/ctl_new_rowid_pillar.cnd_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditioned tibble pillar print method — ctl_new_rowid_pillar.cnd_df","text":"controller object class \"tbl\" currently printed. x simple (one-dimensional) vector. width available width, can vector multiple tiers. ... dots future extensions must empty.","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dataset_oak_vignette.html","id":null,"dir":"Reference","previous_headings":"","what":"Output a Dataset in a Vignette in the sdtm.oak Format — dataset_oak_vignette","title":"Output a Dataset in a Vignette in the sdtm.oak Format — dataset_oak_vignette","text":"Output dataset vignette pre-specified sdtm.oak format.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dataset_oak_vignette.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Output a Dataset in a Vignette in the sdtm.oak Format — dataset_oak_vignette","text":"","code":"dataset_oak_vignette(dataset, display_vars = NULL, filter = NULL)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dataset_oak_vignette.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Output a Dataset in a Vignette in the sdtm.oak Format — dataset_oak_vignette","text":"dataset Dataset output vignette display_vars Variables selected demonstrate outcome mapping Permitted Values: list variables Default NULL display_vars NULL, selected variables visible vignette variables hidden. can made visible clicking theChoose columns display button. filter Filter condition specified condition applied dataset displayed. Permitted Values: condition","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dataset_oak_vignette.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Output a Dataset in a Vignette in the sdtm.oak Format — dataset_oak_vignette","text":"HTML table","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_blfl.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive Baseline Flag or Last Observation Before Exposure Flag — derive_blfl","title":"Derive Baseline Flag or Last Observation Before Exposure Flag — derive_blfl","text":"Derive baseline flag variable (--BLFL) last observation exposure flag (--LOBXFL), observation date/time (--DTC), DM domain reference date/time.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_blfl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive Baseline Flag or Last Observation Before Exposure Flag — derive_blfl","text":"","code":"derive_blfl(   sdtm_in,   dm_domain,   tgt_var,   ref_var,   baseline_visits = character(),   baseline_timepoints = character() )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_blfl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive Baseline Flag or Last Observation Before Exposure Flag — derive_blfl","text":"sdtm_in Input SDTM domain. dm_domain DM domain reference variable ref_var tgt_var Name variable derived (--BLFL --LOBXFL -- domain). ref_var vector date/time Demographics (DM) dataset, serves point comparison observations study. Common choices reference variable include \"RFSTDTC\" (date/time first study treatment) \"RFXSTDTC\" (date/time first exposure study drug). baseline_visits character vector specifying baseline visits within study. visits identified critical points data collection start study, intervention applied.  allows function assign baseline flag --DTC matches reference date. baseline_timepoints character vector timepoints values --TPT specifies specific timepoints baseline visits key assessments measurements taken. allows function assign baseline flag --DTC matches reference date.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_blfl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive Baseline Flag or Last Observation Before Exposure Flag — derive_blfl","text":"Modified input data frame baseline flag variable --BLFL last observation exposure flag --LOBXFL added.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_blfl.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Derive Baseline Flag or Last Observation Before Exposure Flag — derive_blfl","text":"derivation follows: Remove records result (--ORRES) missing. Also, exclude records results labeled \"ND\" (Data) \"DONE\" --ORRES column, indicate measurement observation completed. Remove records status (--STAT) indicates observation test performed, marked \"DONE\". Divide date time column (--DTC) reference date/time variable (ref_var) separate date time components. Ignore seconds recorded time component, focusing hours minutes calculations. Set partial missing dates NA. Set partial missing times NA. Filter rows domain reference dates equal NA. (Ref X) Filter X rows domain date (--DTC) prior (less ) reference date. (Ref ) Filter X rows domain date (--DTC) equal reference date domain reference times equal NA domain time prior (less ) reference time. (Ref B) Filter X rows domain date (--DTC) equal reference date domain /reference time equal NA : VISIT baseline visits list (exists) xxTPT baseline timepoints list (exists). (Ref C) Combine rows , B, C get data frame pre-reference date observations. Sort rows USUBJID, --STAT, --ORRES. Group USUBJID --TESTCD filter rows maximum value --DTC. Keep oak id variables --TESTCD (unique values). Remove duplicate rows. Assign baseline flag variable, --BLFL, last observation exposure flag (--LOBXFL) variable rows. Join baseline flag onto input dataset based oak id vars","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_blfl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Derive Baseline Flag or Last Observation Before Exposure Flag — derive_blfl","text":"","code":"dm <- tibble::tribble(   ~USUBJID, ~RFSTDTC, ~RFXSTDTC,   \"test_study-375\", \"2020-09-28T10:10\", \"2020-09-28T10:10\",   \"test_study-376\", \"2020-09-21T11:00\", \"2020-09-21T11:00\",   \"test_study-377\", NA, NA,   \"test_study-378\", \"2020-01-20T10:00\", \"2020-01-20T10:00\",   \"test_study-379\", NA, NA, )  dm #> # A tibble: 5 × 3 #>   USUBJID        RFSTDTC          RFXSTDTC         #>   <chr>          <chr>            <chr>            #> 1 test_study-375 2020-09-28T10:10 2020-09-28T10:10 #> 2 test_study-376 2020-09-21T11:00 2020-09-21T11:00 #> 3 test_study-377 NA               NA               #> 4 test_study-378 2020-01-20T10:00 2020-01-20T10:00 #> 5 test_study-379 NA               NA                sdtm_in <-   tibble::tribble(     ~DOMAIN,     ~oak_id,     ~raw_source,     ~patient_number,     ~USUBJID,     ~VSDTC,     ~VSTESTCD,     ~VSORRES,     ~VSSTAT,     ~VISIT,     \"VS\",     1L,     \"VTLS1\",     375L,     \"test_study-375\",     \"2020-09-01T13:31\",     \"DIABP\",     \"90\",     NA,     \"SCREENING\",     \"VS\",     2L,     \"VTLS1\",     375L,     \"test_study-375\",     \"2020-10-01T11:20\",     \"DIABP\",     \"90\",     NA,     \"SCREENING\",     \"VS\",     1L,     \"VTLS1\",     375L,     \"test_study-375\",     \"2020-09-28T10:10\",     \"PULSE\",     \"ND\",     NA,     \"SCREENING\",     \"VS\",     2L,     \"VTLS1\",     375L,     \"test_study-375\",     \"2020-10-01T13:31\",     \"PULSE\",     \"85\",     NA,     \"SCREENING\",     \"VS\",     1L,     \"VTLS2\",     375L,     \"test_study-375\",     \"2020-09-28T10:10\",     \"SYSBP\",     \"120\",     NA,     \"SCREENING\",     \"VS\",     2L,     \"VTLS2\",     375L,     \"test_study-375\",     \"2020-09-28T10:05\",     \"SYSBP\",     \"120\",     NA,     \"SCREENING\",     \"VS\",     1L,     \"VTLS1\",     376L,     \"test_study-376\",     \"2020-09-20\",     \"DIABP\",     \"75\",     NA,     \"SCREENING\",     \"VS\",     1L,     \"VTLS1\",     376L,     \"test_study-376\",     \"2020-09-20\",     \"PULSE\",     NA,     \"NOT DONE\",     \"SCREENING\",     \"VS\",     2L,     \"VTLS1\",     376L,     \"test_study-376\",     \"2020-09-20\",     \"PULSE\",     \"110\",     NA,     \"SCREENING\",     \"VS\",     2L,     \"VTLS1\",     378L,     \"test_study-378\",     \"2020-01-20T10:00\",     \"PULSE\",     \"110\",     NA,     \"SCREENING\",     \"VS\",     3L,     \"VTLS1\",     378L,     \"test_study-378\",     \"2020-01-21T11:00\",     \"PULSE\",     \"105\",     NA,     \"SCREENING\"   )  sdtm_in #> # A tibble: 11 × 10 #>    DOMAIN oak_id raw_source patient_number USUBJID VSDTC VSTESTCD VSORRES VSSTAT #>    <chr>   <int> <chr>               <int> <chr>   <chr> <chr>    <chr>   <chr>  #>  1 VS          1 VTLS1                 375 test_s… 2020… DIABP    90      NA     #>  2 VS          2 VTLS1                 375 test_s… 2020… DIABP    90      NA     #>  3 VS          1 VTLS1                 375 test_s… 2020… PULSE    ND      NA     #>  4 VS          2 VTLS1                 375 test_s… 2020… PULSE    85      NA     #>  5 VS          1 VTLS2                 375 test_s… 2020… SYSBP    120     NA     #>  6 VS          2 VTLS2                 375 test_s… 2020… SYSBP    120     NA     #>  7 VS          1 VTLS1                 376 test_s… 2020… DIABP    75      NA     #>  8 VS          1 VTLS1                 376 test_s… 2020… PULSE    NA      NOT D… #>  9 VS          2 VTLS1                 376 test_s… 2020… PULSE    110     NA     #> 10 VS          2 VTLS1                 378 test_s… 2020… PULSE    110     NA     #> 11 VS          3 VTLS1                 378 test_s… 2020… PULSE    105     NA     #> # ℹ 1 more variable: VISIT <chr>  observed_output <- derive_blfl(   sdtm_in = sdtm_in,   dm_domain = dm,   tgt_var = \"VSLOBXFL\",   ref_var = \"RFXSTDTC\",   baseline_visits = c(\"SCREENING\") ) observed_output #> # A tibble: 11 × 11 #>    DOMAIN oak_id raw_source patient_number USUBJID VSDTC VSTESTCD VSORRES VSSTAT #>    <chr>   <int> <chr>               <int> <chr>   <chr> <chr>    <chr>   <chr>  #>  1 VS          1 VTLS1                 375 test_s… 2020… DIABP    90      NA     #>  2 VS          2 VTLS1                 375 test_s… 2020… DIABP    90      NA     #>  3 VS          1 VTLS1                 375 test_s… 2020… PULSE    ND      NA     #>  4 VS          2 VTLS1                 375 test_s… 2020… PULSE    85      NA     #>  5 VS          1 VTLS2                 375 test_s… 2020… SYSBP    120     NA     #>  6 VS          2 VTLS2                 375 test_s… 2020… SYSBP    120     NA     #>  7 VS          1 VTLS1                 376 test_s… 2020… DIABP    75      NA     #>  8 VS          1 VTLS1                 376 test_s… 2020… PULSE    NA      NOT D… #>  9 VS          2 VTLS1                 376 test_s… 2020… PULSE    110     NA     #> 10 VS          2 VTLS1                 378 test_s… 2020… PULSE    110     NA     #> 11 VS          3 VTLS1                 378 test_s… 2020… PULSE    105     NA     #> # ℹ 2 more variables: VISIT <chr>, VSLOBXFL <chr>"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive the sequence number (--SEQ) variable — derive_seq","title":"Derive the sequence number (--SEQ) variable — derive_seq","text":"derive_seq() creates new identifier variable: sequence number (--SEQ). function adds newly derived variable tgt_dat, namely sequence number (--SEQ) whose name one provided tgt_var. integer sequence generated uniquely identifies record within domain. Prior derivation tgt_var, data frame tgt_dat sorted according grouping variables indicated rec_vars.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive the sequence number (--SEQ) variable — derive_seq","text":"","code":"derive_seq(   tgt_dat,   tgt_var,   rec_vars,   sbj_vars = sdtm.oak::sbj_vars(),   start_at = 1L )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive the sequence number (--SEQ) variable — derive_seq","text":"tgt_dat target dataset, data frame. tgt_var target SDTM variable: single string indicating name sequence number (--SEQ) variable, e.g. \"DSSEQ\". Note supplying name ending \"SEQ\" raise warning. rec_vars character vector record-level identifier variables. sbj_vars character vector subject-level identifier variables. start_at sequence numbering starts value (default 1).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive the sequence number (--SEQ) variable — derive_seq","text":"Returns data frame supplied tgt_dat newly derived variable, .e. sequence number (--SEQ), whose name passed tgt_var. variable type integer.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Derive the sequence number (--SEQ) variable — derive_seq","text":"","code":"# A VS raw data set example (vs <- read_domain_example(\"vs\")) #> # A tibble: 6 × 7 #>   STUDYID DOMAIN USUBJID    VSSPID                 VSTESTCD VSDTC       VSTPTNUM #>   <chr>   <chr>  <chr>      <chr>                  <chr>    <chr>          <dbl> #> 1 ABC123  VS     ABC123-375 /F:VTLS1-D:9795532-R:2 DIABP    2020-09-01…       NA #> 2 ABC123  VS     ABC123-375 /F:VTLS1-D:9795532-R:2 TEMP     2020-09-01…       NA #> 3 ABC123  VS     ABC123-375 /F:VTLS2-D:9795533-R:2 DIABP    2020-09-28…        2 #> 4 ABC123  VS     ABC123-375 /F:VTLS2-D:9795533-R:2 TEMP     2020-09-28…        2 #> 5 ABC123  VS     ABC123-376 /F:VTLS1-D:9795591-R:1 DIABP    2020-09-20        NA #> 6 ABC123  VS     ABC123-376 /F:VTLS1-D:9795591-R:1 TEMP     2020-09-20        NA  # Derivation of VSSEQ rec_vars <- c(\"STUDYID\", \"USUBJID\", \"VSTESTCD\", \"VSDTC\", \"VSTPTNUM\") derive_seq(tgt_dat = vs, tgt_var = \"VSSEQ\", rec_vars = rec_vars) #> # A tibble: 6 × 8 #>   STUDYID DOMAIN USUBJID    VSSPID                 VSTESTCD VSDTC VSTPTNUM VSSEQ #>   <chr>   <chr>  <chr>      <chr>                  <chr>    <chr>    <dbl> <int> #> 1 ABC123  VS     ABC123-375 /F:VTLS1-D:9795532-R:2 DIABP    2020…       NA     1 #> 2 ABC123  VS     ABC123-375 /F:VTLS2-D:9795533-R:2 DIABP    2020…        2     2 #> 3 ABC123  VS     ABC123-375 /F:VTLS1-D:9795532-R:2 TEMP     2020…       NA     3 #> 4 ABC123  VS     ABC123-375 /F:VTLS2-D:9795533-R:2 TEMP     2020…        2     4 #> 5 ABC123  VS     ABC123-376 /F:VTLS1-D:9795591-R:1 DIABP    2020…       NA     1 #> 6 ABC123  VS     ABC123-376 /F:VTLS1-D:9795591-R:1 TEMP     2020…       NA     2  # An APSC raw data set example (apsc <- read_domain_example(\"apsc\")) #> # A tibble: 6 × 6 #>   STUDYID RSUBJID    SCTESTCD DOMAIN SREL    SCCAT          #>   <chr>   <chr>      <chr>    <chr>  <chr>   <chr>          #> 1 ABC123  ABC123-210 LVSBJIND APSC   FRIEND  CAREGIVERSTUDY #> 2 ABC123  ABC123-210 EDULEVEL APSC   FRIEND  CAREGIVERSTUDY #> 3 ABC123  ABC123-210 TMSPPT   APSC   FRIEND  CAREGIVERSTUDY #> 4 ABC123  ABC123-211 CAREDUR  APSC   SIBLING CAREGIVERSTUDY #> 5 ABC123  ABC123-211 LVSBJIND APSC   SIBLING CAREGIVERSTUDY #> 6 ABC123  ABC123-212 JOBCLAS  APSC   SPOUSE  CAREGIVERSTUDY  # Derivation of APSEQ derive_seq(   tgt_dat = apsc,   tgt_var = \"APSEQ\",   rec_vars = c(\"STUDYID\", \"RSUBJID\", \"SCTESTCD\"),   sbj_vars = c(\"STUDYID\", \"RSUBJID\") ) #> # A tibble: 6 × 7 #>   STUDYID RSUBJID    SCTESTCD DOMAIN SREL    SCCAT          APSEQ #>   <chr>   <chr>      <chr>    <chr>  <chr>   <chr>          <int> #> 1 ABC123  ABC123-210 EDULEVEL APSC   FRIEND  CAREGIVERSTUDY     1 #> 2 ABC123  ABC123-210 LVSBJIND APSC   FRIEND  CAREGIVERSTUDY     2 #> 3 ABC123  ABC123-210 TMSPPT   APSC   FRIEND  CAREGIVERSTUDY     3 #> 4 ABC123  ABC123-211 CAREDUR  APSC   SIBLING CAREGIVERSTUDY     1 #> 5 ABC123  ABC123-211 LVSBJIND APSC   SIBLING CAREGIVERSTUDY     2 #> 6 ABC123  ABC123-212 JOBCLAS  APSC   SPOUSE  CAREGIVERSTUDY     1"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_study_day.html","id":null,"dir":"Reference","previous_headings":"","what":"derive_study_day performs study day calculation — derive_study_day","title":"derive_study_day performs study day calculation — derive_study_day","text":"function takes input data frame reference data frame (DM domain cases), calculate study day reference date target date. case unexpected conditions like reference date unique patient, reference input dates actual dates, NA returned records.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_study_day.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"derive_study_day performs study day calculation — derive_study_day","text":"","code":"derive_study_day(   sdtm_in,   dm_domain,   tgdt,   refdt,   study_day_var,   merge_key = \"USUBJID\" )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_study_day.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"derive_study_day performs study day calculation — derive_study_day","text":"sdtm_in Input data frame contains target date. dm_domain Reference date frame contains reference date. tgdt Target date sdtm_in used calculate study day. refdt Reference date dm_domain used reference calculate study day. study_day_var New study day variable name output. example, AESTDY AE domain CMSTDY CM domain. merge_key Character represent merging key sdtm_in dm_domain.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_study_day.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"derive_study_day performs study day calculation — derive_study_day","text":"Data frame takes columns sdtm_in new variable represent calculated study day.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/derive_study_day.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"derive_study_day performs study day calculation — derive_study_day","text":"","code":"ae <- data.frame(   USUBJID = c(\"study123-123\", \"study123-124\", \"study123-125\"),   AESTDTC = c(\"2012-01-01\", \"2012-04-14\", \"2012-04-14\") ) dm <- data.frame(   USUBJID = c(\"study123-123\", \"study123-124\", \"study123-125\"),   RFSTDTC = c(\"2012-02-01\", \"2012-04-14\", NA) ) ae$AESTDTC <- as.Date(ae$AESTDTC) dm$RFSTDTC <- as.Date(dm$RFSTDTC) derive_study_day(ae, dm, \"AESTDTC\", \"RFSTDTC\", \"AESTDY\") #>        USUBJID    AESTDTC AESTDY #> 1 study123-123 2012-01-01    -31 #> 2 study123-124 2012-04-14      1 #> 3 study123-125 2012-04-14     NA"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/domain_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the path to an example SDTM domain file — domain_example","title":"Find the path to an example SDTM domain file — domain_example","text":"domain_example() resolves local path SDTM domain example file. domain examples files imported pharmaversesdtm. See Details section available datasets.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/domain_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the path to an example SDTM domain file — domain_example","text":"","code":"domain_example(example)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/domain_example.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Find the path to an example SDTM domain file — domain_example","text":"See https://cran.r-project.org/package=pharmaversesdtm.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/domain_example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the path to an example SDTM domain file — domain_example","text":"example string either basename, file name, relative path SDTM domain example file bundled {stdm.oak}, e.g. \"cm\" (Concomitant Medication) \"ae\" (Adverse Events).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/domain_example.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the path to an example SDTM domain file — domain_example","text":"local path example file example supplied, character vector example file names.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/domain_example.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find the path to an example SDTM domain file — domain_example","text":"Datasets obtained pharmaversesdtm originally sourced CDISC pilot project constructed ad-hoc admiral team. datasets bundled {sdtm.oak}, thus obviating dependence {pharmaversesdtm}.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/domain_example.html","id":"example-sdtm-domains","dir":"Reference","previous_headings":"","what":"Example SDTM domains","title":"Find the path to an example SDTM domain file — domain_example","text":"\"ae\": Adverse Events (AE) data set. \"apsc\": Associated Persons Subject Characteristics (APSC) data set. \"cm\": Concomitant Medications (CM) data set. \"vs\": Vital Signs (VS) data set.","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/domain_example.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the path to an example SDTM domain file — domain_example","text":"","code":"# If no example is provided it returns a vector of possible choices. domain_example() #> [1] \"ae\"   \"apsc\" \"cm\"   \"vs\"    # Get the local path to the Concomitant Medication dataset file. domain_example(\"cm\") #> [1] \"/renv/lib/R-4.3/x86_64-pc-linux-gnu/sdtm.oak/domain/cm.rds\"  # Local path to the Adverse Events dataset file. domain_example(\"ae\") #> [1] \"/renv/lib/R-4.3/x86_64-pc-linux-gnu/sdtm.oak/domain/ae.rds\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dot_pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Explicit Dot Pipe — %.>%","title":"Explicit Dot Pipe — %.>%","text":"operator pipes object forward function call expression using explicit placement dot (.) placeholder. Unlike magrittr's %>% operator, %.>% automatically place left-hand side (lhs) first argument right-hand side (rhs) call. operator provides simpler alternative use braces magrittr, achieving similar behavior.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dot_pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Explicit Dot Pipe — %.>%","text":"","code":"lhs %.>% rhs"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dot_pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Explicit Dot Pipe — %.>%","text":"lhs value piped forward. rhs function call utilizes dot (.) placeholder specify lhs placed.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dot_pipe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Explicit Dot Pipe — %.>%","text":"%.>% operator used pipe lhs value rhs function call. Within rhs expression, placeholder . represents position lhs inserted. provides control lhs value appears rhs function call, compared magrittr pipe operator always places lhs first argument rhs. Unlike magrittr's pipe, may require use braces fully control placement lhs nested function calls, %.>% simplifies directly allowing multiple usages dot placeholder without requiring braces. example, following expression using magrittr's pipe braces:   can written :   without needing additional braces.","code":"library(magrittr)  1:10 %>% { c(min(.), max(.)) } 1:10 %.>% c(min(.), max(.))"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dot_pipe.html","id":"downside","dir":"Reference","previous_headings":"","what":"Downside","title":"Explicit Dot Pipe — %.>%","text":"disadvantage %.>% always need use dot placeholder, even piping first argument right-hand side (rhs).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dot_pipe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Explicit Dot Pipe — %.>%","text":"","code":"# Equivalent to `subset(head(iris), 1:nrow(head(iris)) %% 2 == 0)` head(iris) %.>% subset(., 1:nrow(.) %% 2 == 0) #>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 2          4.9         3.0          1.4         0.2  setosa #> 4          4.6         3.1          1.5         0.2  setosa #> 6          5.4         3.9          1.7         0.4  setosa  # Equivalent to `c(min(1:10), max(1:10))` 1:10 %.>% c(min(.), max(.)) #> [1]  1 10"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_datepart.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract date part from ISO8601 date/time variable — dtc_datepart","title":"Extract date part from ISO8601 date/time variable — dtc_datepart","text":"date part extracted ISO8601 date/time variable. default, partial missing dates set NA.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_datepart.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract date part from ISO8601 date/time variable — dtc_datepart","text":"","code":"dtc_datepart(dtc, partial_as_na = TRUE)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_datepart.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract date part from ISO8601 date/time variable — dtc_datepart","text":"dtc Character vector containing ISO8601 date/times. partial_as_na Logical TRUE FALSE indicating whether partial dates set NA (default TRUE).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_datepart.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract date part from ISO8601 date/time variable — dtc_datepart","text":"Character vector containing ISO8601 dates.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_formats.html","id":null,"dir":"Reference","previous_headings":"","what":"Date/time collection formats — dtc_formats","title":"Date/time collection formats — dtc_formats","text":"Date/time collection formats","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_formats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Date/time collection formats — dtc_formats","text":"","code":"dtc_formats"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_formats.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Date/time collection formats — dtc_formats","text":"tibble 20 formats three variables: fmt Format string. type Whether date, time date-time. description Description date-time components parsed.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_formats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Date/time collection formats — dtc_formats","text":"","code":"dtc_formats #> # A tibble: 20 × 3 #>    fmt         type     description                                              #>    <chr>       <chr>    <chr>                                                    #>  1 ymd         date     Parses a date: year, month, and month day.               #>  2 y m d       date     Parses a date: year, month, and month day.               #>  3 y-m-d       date     Parses a date: year, month, and month day.               #>  4 dmy         date     Parses a date: month day, month and year.                #>  5 d m y       date     Parses a date: month day, month and year.                #>  6 d-m-y       date     Parses a date: month day, month and year.                #>  7 ym          date     Parses a date: year and month.                           #>  8 y m         date     Parses a date: year and month.                           #>  9 y-m         date     Parses a date: year and month.                           #> 10 my          date     Parses a date: month and year.                           #> 11 m y         date     Parses a date: month and year.                           #> 12 m-y         date     Parses a date: month and year.                           #> 13 HM          time     Parses a time: hour and minutes.                         #> 14 HMS         time     Parses a time: hour, minutes, and seconds.               #> 15 H:M         time     Parses a time: hour and minutes.                         #> 16 H:M:S       time     Parses a time: hour, minutes and seconds.                #> 17 ymdH:M:S    datetime Parses a date-time: year, month, month day, hour, minut… #> 18 ymd H:M:S   datetime Parses a date-time: year, month, month day, hour, minut… #> 19 y-m-d H:M:S datetime Parses a date-time: year, month, month day, hour, minut… #> 20 y m d H:M:S datetime Parses a date-time: year, month, month day, hour, minut…"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_timepart.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract time part from ISO 8601 date/time variable — dtc_timepart","title":"Extract time part from ISO 8601 date/time variable — dtc_timepart","text":"time part extracted ISO 8601 date/time variable. default, partial missing times set NA, seconds ignored extracted.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_timepart.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract time part from ISO 8601 date/time variable — dtc_timepart","text":"","code":"dtc_timepart(dtc, partial_as_na = TRUE, ignore_seconds = TRUE)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_timepart.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract time part from ISO 8601 date/time variable — dtc_timepart","text":"dtc Character vector containing ISO 8601 date/times. partial_as_na Logical TRUE FALSE indicating whether partial times set NA (default TRUE). ignore_seconds Logical TRUE FALSE indicating whether seconds ignored (default TRUE).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dtc_timepart.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract time part from ISO 8601 date/time variable — dtc_timepart","text":"Character vector containing ISO 8601 times.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dttm_fmt_to_regex.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a parsed date/time format to regex — dttm_fmt_to_regex","title":"Convert a parsed date/time format to regex — dttm_fmt_to_regex","text":"dttm_fmt_to_regex() takes tibble parsed date/time format components (returned parse_dttm_fmt()), mapping date/time component formats regexps generates single regular expression groups matching date/time components.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dttm_fmt_to_regex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a parsed date/time format to regex — dttm_fmt_to_regex","text":"","code":"dttm_fmt_to_regex(   fmt,   fmt_regex = fmt_rg(),   fmt_c = fmt_cmp(),   anchored = TRUE )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dttm_fmt_to_regex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a parsed date/time format to regex — dttm_fmt_to_regex","text":"fmt format string (scalar) parsed patterns. fmt_regex named character vector regexps, one date/time component. anchored Whether final regex anchored, .e. bounded \"^\" \"$\" whole match.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/dttm_fmt_to_regex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a parsed date/time format to regex — dttm_fmt_to_regex","text":"string containing regular expression matching date/time components according format.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/eval_conditions.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate conditions — eval_conditions","title":"Evaluate conditions — eval_conditions","text":"eval_conditions() evaluates set conditions context data frame optional environment. utility function provide easy way generate logical vector matching records set logical conditions involving variables data frame (dat) optionally supplementary environment (.env). set logical conditions provided expressions evaluated context dat .env. Variables looked dat, .env, calling function's environment, followed parent environments.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/eval_conditions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate conditions — eval_conditions","text":"","code":"eval_conditions(dat, ..., .na = NA, .env = rlang::caller_env())"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/eval_conditions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate conditions — eval_conditions","text":"dat data frame ... set logical conditions, e.g. y & z, x | z (x, y, z exist either columns dat environment .env). multiple expressions included, combined & operator. .na Return value used conditions evaluate NA. .env optional environment look variables involved logical expression passed .... data frame list can also passed coerced environment internally.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/eval_conditions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate conditions — eval_conditions","text":"logical vector reflecting matching rows dat.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/find_int_gap.html","id":null,"dir":"Reference","previous_headings":"","what":"Find gap intervals in integer sequences — find_int_gap","title":"Find gap intervals in integer sequences — find_int_gap","text":"find_int_gap() determines start end positions gap intervals sequence integers. default, interval range look gaps defined minimum maximum values x; specify xmin xmax change range explicitly.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/find_int_gap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find gap intervals in integer sequences — find_int_gap","text":"","code":"find_int_gap(x, xmin = min(x), xmax = max(x))"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/find_int_gap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find gap intervals in integer sequences — find_int_gap","text":"x integer vector. xmin Left endpoint integer value. xmax Right endpoint integer value.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/find_int_gap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find gap intervals in integer sequences — find_int_gap","text":"tibble gap intervals two columns: start: left endpoint end: right endpoint gap intervals found empty tibble returned.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_cmp.html","id":null,"dir":"Reference","previous_headings":"","what":"Regexps for date/time format components — fmt_cmp","title":"Regexps for date/time format components — fmt_cmp","text":"fmt_cmp() creates character vector patterns match individual format date/time components.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_cmp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regexps for date/time format components — fmt_cmp","text":"","code":"fmt_cmp(   sec = \"S+\",   min = \"M+\",   hour = \"H+\",   mday = \"d+\",   mon = \"m+\",   year = \"y+\" )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_cmp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regexps for date/time format components — fmt_cmp","text":"sec string pattern matching second format component. min string pattern matching minute format component. hour string pattern matching hour format component. mday string pattern matching month day format component. mon string pattern matching month format component. year string pattern matching year format component.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_cmp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regexps for date/time format components — fmt_cmp","text":"named character vector date/time format patterns. vector six elements, one date/time component.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_cmp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regexps for date/time format components — fmt_cmp","text":"","code":"# Regexps to parse format components fmt_cmp() #> $sec #> [1] \"S+\" #>  #> $min #> [1] \"M+\" #>  #> $hour #> [1] \"H+\" #>  #> $mday #> [1] \"d+\" #>  #> $mon #> [1] \"m+\" #>  #> $year #> [1] \"y+\" #>  #> attr(,\"class\") #> [1] \"fmt_c\"  fmt_cmp(year = \"yyyy\") #> $sec #> [1] \"S+\" #>  #> $min #> [1] \"M+\" #>  #> $hour #> [1] \"H+\" #>  #> $mday #> [1] \"d+\" #>  #> $mon #> [1] \"m+\" #>  #> $year #> [1] \"yyyy\" #>  #> attr(,\"class\") #> [1] \"fmt_c\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_rg.html","id":null,"dir":"Reference","previous_headings":"","what":"Regexps for date/time components — fmt_rg","title":"Regexps for date/time components — fmt_rg","text":"fmt_rg() creates character vector named patterns match individual date/time components.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_rg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regexps for date/time components — fmt_rg","text":"","code":"fmt_rg(   sec = \"(\\\\b\\\\d|\\\\d{2})(\\\\.\\\\d*)?\",   min = \"(\\\\b\\\\d|\\\\d{2})\",   hour = \"\\\\d?\\\\d\",   mday = \"\\\\b\\\\d|\\\\d{2}\",   mon = stringr::str_glue(\"\\\\d\\\\d|{months_abb_regex()}\"),   year = \"(\\\\d{2})?\\\\d{2}\",   na = NULL,   sec_na = na,   min_na = na,   hour_na = na,   mday_na = na,   mon_na = na,   year_na = na )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_rg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regexps for date/time components — fmt_rg","text":"sec Regexp second component. min Regexp minute component. hour Regexp hour component. mday Regexp month day component. mon Regexp month component. year Regexp year component. na Regexp alternatives, useful match special values coding missingness. sec_na na specifically second component. min_na na specifically minute component. hour_na na specifically hour component. mday_na na specifically month day component. mon_na na specifically month component. year_na na specifically year component.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/fmt_rg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regexps for date/time components — fmt_rg","text":"named character vector named patterns (regexps) matching date/time component.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/format_iso8601.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert date/time components into ISO8601 format — format_iso8601","title":"Convert date/time components into ISO8601 format — format_iso8601","text":"format_iso8601() takes character matrix date/time components converts component ISO8601 format. practice entails converting years four digit number, month, day, hours, minutes seconds two-digit numbers. available (NA) components converted \"-\".","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/format_iso8601.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert date/time components into ISO8601 format — format_iso8601","text":"","code":"format_iso8601(m, .cutoff_2000 = 68L)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/format_iso8601.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert date/time components into ISO8601 format — format_iso8601","text":"m character matrix date/time components. must six named columns: year, mon, mday, hour, min sec. .cutoff_2000 integer value. Two-digit years smaller equal .cutoff_2000 parsed though starting 20, otherwise parsed though starting 19.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/format_iso8601.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert date/time components into ISO8601 format — format_iso8601","text":"character vector date-times following ISO8601 format.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/generate_oak_id_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to generate oak_id_vars — generate_oak_id_vars","title":"A function to generate oak_id_vars — generate_oak_id_vars","text":"function generate oak_id_vars","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/generate_oak_id_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to generate oak_id_vars — generate_oak_id_vars","text":"","code":"generate_oak_id_vars(raw_dat, pat_var, raw_src)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/generate_oak_id_vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to generate oak_id_vars — generate_oak_id_vars","text":"raw_dat raw dataset (dataframe) pat_var Variable holds patient number raw_src Name raw source","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/generate_oak_id_vars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to generate oak_id_vars — generate_oak_id_vars","text":"dataframe","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/generate_oak_id_vars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A function to generate oak_id_vars — generate_oak_id_vars","text":"","code":"raw_dataset <-   tibble::tribble(     ~patnum, ~MDRAW,     101L, \"BABY ASPIRIN\",     102L, \"CORTISPORIN\",     103L, NA_character_,     104L, \"DIPHENHYDRAMINE HCL\"   )  # Generate oak_id_vars generate_oak_id_vars(   raw_dat = raw_dataset,   pat_var = \"patnum\",   raw_src = \"Concomitant Medication\" ) #> # A tibble: 4 × 5 #>   oak_id raw_source             patient_number patnum MDRAW               #>    <int> <chr>                           <int>  <int> <chr>               #> 1      1 Concomitant Medication            101    101 BABY ASPIRIN        #> 2      2 Concomitant Medication            102    102 CORTISPORIN         #> 3      3 Concomitant Medication            103    103 NA                  #> 4      4 Concomitant Medication            104    104 DIPHENHYDRAMINE HCL"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/get_cnd_df_cnd.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the conditioning vector from a conditioned data frame — get_cnd_df_cnd","title":"Get the conditioning vector from a conditioned data frame — get_cnd_df_cnd","text":"get_cnd_df_cnd() extracts conditioning vector conditioned data frame, .e. object class cnd_df.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/get_cnd_df_cnd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the conditioning vector from a conditioned data frame — get_cnd_df_cnd","text":"","code":"get_cnd_df_cnd(dat)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/get_cnd_df_cnd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the conditioning vector from a conditioned data frame — get_cnd_df_cnd","text":"dat conditioned data frame (cnd_df).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/get_cnd_df_cnd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the conditioning vector from a conditioned data frame — get_cnd_df_cnd","text":"conditioning vector (cnd) dat conditioned data frame (cnd_df), otherwise NULL, NULL dat conditioned data frame (cnd_df).","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/get_cnd_df_cnd_sum.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the summary of the conditioning vector from a conditioned data frame — get_cnd_df_cnd_sum","title":"Get the summary of the conditioning vector from a conditioned data frame — get_cnd_df_cnd_sum","text":"get_cnd_df_cnd_sum() extracts tally conditioning vector conditioned data frame.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/get_cnd_df_cnd_sum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the summary of the conditioning vector from a conditioned data frame — get_cnd_df_cnd_sum","text":"","code":"get_cnd_df_cnd_sum(dat)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/get_cnd_df_cnd_sum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the summary of the conditioning vector from a conditioned data frame — get_cnd_df_cnd_sum","text":"dat conditioned data frame (cnd_df).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/get_cnd_df_cnd_sum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the summary of the conditioning vector from a conditioned data frame — get_cnd_df_cnd_sum","text":"vector three elements providing sum TRUE, FALSE, NA values conditioning vector (cnd), NULL dat conditioned data frame (cnd_df).","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/harcode.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive an SDTM variable with a hardcoded value — harcode","title":"Derive an SDTM variable with a hardcoded value — harcode","text":"hardcode_no_ct() maps hardcoded value target SDTM variable terminology restrictions. hardcode_ct() maps hardcoded value target SDTM variable controlled terminology recoding.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/harcode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive an SDTM variable with a hardcoded value — harcode","text":"","code":"hardcode_no_ct(   tgt_dat = NULL,   tgt_val,   raw_dat,   raw_var,   tgt_var,   id_vars = oak_id_vars() )  hardcode_ct(   tgt_dat = NULL,   tgt_val,   raw_dat,   raw_var,   tgt_var,   ct_spec,   ct_clst,   id_vars = oak_id_vars() )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/harcode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive an SDTM variable with a hardcoded value — harcode","text":"tgt_dat Target dataset: data frame merged raw_dat variables indicated id_vars. parameter optional, see section Value output changes depending argument value. tgt_val target SDTM value hardcoded variable indicated tgt_var. raw_dat raw dataset (dataframe); must include variables passed id_vars raw_var. raw_var raw variable: single string indicating name raw variable raw_dat. tgt_var target SDTM variable: single string indicating name variable derived. id_vars Key variables used join raw dataset (raw_dat) target data set (raw_dat). ct_spec Study controlled terminology specification: dataframe minimal set columns, see ct_spec_vars() details. parameter optional, left NULL controlled terminology recoding applied. ct_clst codelist code indicating subset controlled terminology apply derivation. parameter optional, left NULL, possible recodings ct_spec attempted.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/harcode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive an SDTM variable with a hardcoded value — harcode","text":"returned data set depends value tgt_dat: target dataset supplied, meaning tgt_dat defaults NULL, returned data set raw_dat, selected variables indicated id_vars, new extra column: derived variable, indicated tgt_var. target dataset provided, merged raw data set raw_dat variables indicated id_vars, new column: derived variable, indicated tgt_var.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/harcode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Derive an SDTM variable with a hardcoded value — harcode","text":"","code":"md1 <-   tibble::tribble(     ~oak_id, ~raw_source, ~patient_number, ~MDRAW,     1L,      \"MD1\",       101L,            \"BABY ASPIRIN\",     2L,      \"MD1\",       102L,            \"CORTISPORIN\",     3L,      \"MD1\",       103L,            NA_character_,     4L,      \"MD1\",       104L,            \"DIPHENHYDRAMINE HCL\"   )  # Derive a new variable `CMCAT` by overwriting `MDRAW` with the # hardcoded value \"GENERAL CONCOMITANT MEDICATIONS\". hardcode_no_ct(   tgt_val = \"GENERAL CONCOMITANT MEDICATIONS\",   raw_dat = md1,   raw_var = \"MDRAW\",   tgt_var = \"CMCAT\" ) #> # A tibble: 4 × 4 #>   oak_id raw_source patient_number CMCAT                           #>    <int> <chr>               <int> <chr>                           #> 1      1 MD1                   101 GENERAL CONCOMITANT MEDICATIONS #> 2      2 MD1                   102 GENERAL CONCOMITANT MEDICATIONS #> 3      3 MD1                   103 NA                              #> 4      4 MD1                   104 GENERAL CONCOMITANT MEDICATIONS  cm_inter <-   tibble::tribble(     ~oak_id, ~raw_source, ~patient_number, ~CMTRT,                ~CMINDC,     1L,      \"MD1\",       101L,            \"BABY ASPIRIN\",        NA,     2L,      \"MD1\",       102L,            \"CORTISPORIN\",         \"NAUSEA\",     3L,      \"MD1\",       103L,            \"ASPIRIN\",             \"ANEMIA\",     4L,      \"MD1\",       104L,            \"DIPHENHYDRAMINE HCL\", \"NAUSEA\",     5L,      \"MD1\",       105L,            \"PARACETAMOL\",         \"PYREXIA\"   )  # Derive a new variable `CMCAT` by overwriting `MDRAW` with the # hardcoded value \"GENERAL CONCOMITANT MEDICATIONS\" with a prior join to # `target_dataset`. hardcode_no_ct(   tgt_dat = cm_inter,   tgt_val = \"GENERAL CONCOMITANT MEDICATIONS\",   raw_dat = md1,   raw_var = \"MDRAW\",   tgt_var = \"CMCAT\" ) #> # A tibble: 5 × 6 #>   oak_id raw_source patient_number CMTRT               CMINDC  CMCAT             #>    <int> <chr>               <int> <chr>               <chr>   <chr>             #> 1      1 MD1                   101 BABY ASPIRIN        NA      GENERAL CONCOMIT… #> 2      2 MD1                   102 CORTISPORIN         NAUSEA  GENERAL CONCOMIT… #> 3      3 MD1                   103 ASPIRIN             ANEMIA  NA                #> 4      4 MD1                   104 DIPHENHYDRAMINE HCL NAUSEA  GENERAL CONCOMIT… #> 5      5 MD1                   105 PARACETAMOL         PYREXIA NA                 # Controlled terminology specification (ct_spec <- read_ct_spec_example(\"ct-01-cm\")) #> # A tibble: 33 × 8 #>    codelist_code term_code CodedData term_value collected_value     #>    <chr>         <chr>     <chr>     <chr>      <chr>               #>  1 C71113        C25473    QD        QD         QD (Every Day)      #>  2 C71113        C64496    BID       BID        BID (Twice a Day)   #>  3 C71113        C64499    PRN       PRN        PRN (As Needed)     #>  4 C71113        C64516    Q2H       Q2H        Q2H (Every 2 Hours) #>  5 C71113        C64530    QID       QID        QID (4 Times a Day) #>  6 C66726        C25158    CAPSULE   CAPSULE    Capsule             #>  7 C66726        C25394    PILL      PILL       Pill                #>  8 C66726        C29167    LOTION    LOTION     Lotion              #>  9 C66726        C42887    AEROSOL   AEROSOL    Aerosol             #> 10 C66726        C42944    INHALANT  INHALANT   Inhalant            #> # ℹ 23 more rows #> # ℹ 3 more variables: term_preferred_term <chr>, term_synonyms <chr>, #> #   raw_codelist <chr>  # Hardcoding of `CMCAT` with the value `\"GENERAL CONCOMITANT MEDICATIONS\"` # involving terminology recoding. `NA` values in `MDRAW` are preserved in # `CMCAT`. hardcode_ct(   tgt_dat = cm_inter,   tgt_var = \"CMCAT\",   raw_dat = md1,   raw_var = \"MDRAW\",   tgt_val = \"GENERAL CONCOMITANT MEDICATIONS\",   ct_spec = ct_spec,   ct_clst = \"C66729\" ) #> # A tibble: 5 × 6 #>   oak_id raw_source patient_number CMTRT               CMINDC  CMCAT             #>    <int> <chr>               <int> <chr>               <chr>   <chr>             #> 1      1 MD1                   101 BABY ASPIRIN        NA      GENERAL CONCOMIT… #> 2      2 MD1                   102 CORTISPORIN         NAUSEA  GENERAL CONCOMIT… #> 3      3 MD1                   103 ASPIRIN             ANEMIA  NA                #> 4      4 MD1                   104 DIPHENHYDRAMINE HCL NAUSEA  GENERAL CONCOMIT… #> 5      5 MD1                   105 PARACETAMOL         PYREXIA NA"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/index_for_recode.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine Indices for Recoding — index_for_recode","title":"Determine Indices for Recoding — index_for_recode","text":"index_for_recode() identifies positions elements x match values specified vector. function primarily used facilitate recoding values pinpointing elements x correspond values thus need replaced updated.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/index_for_recode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine Indices for Recoding — index_for_recode","text":"","code":"index_for_recode(x, from)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/index_for_recode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine Indices for Recoding — index_for_recode","text":"x vector values search matches. vector values match elements x.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/index_for_recode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine Indices for Recoding — index_for_recode","text":"integer vector length x, containing indices matched values vector. element x match value , corresponding position output NA. index information critical subsequent recoding operations.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/is_cnd_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a data frame is a conditioned data frame — is_cnd_df","title":"Check if a data frame is a conditioned data frame — is_cnd_df","text":"is_cnd_df() checks whether data frame conditioned data frame, .e. class cnd_df.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/is_cnd_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a data frame is a conditioned data frame — is_cnd_df","text":"","code":"is_cnd_df(dat)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/is_cnd_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a data frame is a conditioned data frame — is_cnd_df","text":"dat data frame.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/is_cnd_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if a data frame is a conditioned data frame — is_cnd_df","text":"TRUE dat conditioned data frame (class cnd_df), otherwise FALSE.","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/is_seq_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Is it a --SEQ variable name — is_seq_name","title":"Is it a --SEQ variable name — is_seq_name","text":"is_seq_name() returns variable names end \"SEQ\".","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/is_seq_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is it a --SEQ variable name — is_seq_name","text":"","code":"is_seq_name(x)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/is_seq_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is it a --SEQ variable name — is_seq_name","text":"x character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/is_seq_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is it a --SEQ variable name — is_seq_name","text":"logical vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_mon.html","id":null,"dir":"Reference","previous_headings":"","what":"Format as a ISO8601 month — iso8601_mon","title":"Format as a ISO8601 month — iso8601_mon","text":"iso8601_mon() converts character vector whose values represent numeric abbreviated month names zero-padded numeric months.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_mon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format as a ISO8601 month — iso8601_mon","text":"","code":"iso8601_mon(x)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_mon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format as a ISO8601 month — iso8601_mon","text":"x character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_mon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format as a ISO8601 month — iso8601_mon","text":"character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert NA to ","title":"Convert NA to ","text":"iso8601_na() takes character vector converts NA values \"-\".","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert NA to ","text":"","code":"iso8601_na(x)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert NA to ","text":"x character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert NA to ","text":"character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_sec.html","id":null,"dir":"Reference","previous_headings":"","what":"Format as ISO8601 seconds — iso8601_sec","title":"Format as ISO8601 seconds — iso8601_sec","text":"iso8601_sec() converts character vector whose values represent seconds.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_sec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format as ISO8601 seconds — iso8601_sec","text":"","code":"iso8601_sec(x)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_sec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format as ISO8601 seconds — iso8601_sec","text":"x character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_sec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format as ISO8601 seconds — iso8601_sec","text":"character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_truncate.html","id":null,"dir":"Reference","previous_headings":"","what":"Truncate a partial ISO8601 date-time — iso8601_truncate","title":"Truncate a partial ISO8601 date-time — iso8601_truncate","text":"iso8601_truncate() converts character vector ISO8601 dates, times date-times might partial truncates format removing missing components.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_truncate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Truncate a partial ISO8601 date-time — iso8601_truncate","text":"","code":"iso8601_truncate(x, empty_as_na = TRUE)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_truncate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Truncate a partial ISO8601 date-time — iso8601_truncate","text":"x character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_truncate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Truncate a partial ISO8601 date-time — iso8601_truncate","text":"character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_two_digits.html","id":null,"dir":"Reference","previous_headings":"","what":"Format as a ISO8601 two-digit number — iso8601_two_digits","title":"Format as a ISO8601 two-digit number — iso8601_two_digits","text":"iso8601_two_digits() converts single digit two digit number two digit, 0-padded, number. Failing parse input two digit number results NA.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_two_digits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format as a ISO8601 two-digit number — iso8601_two_digits","text":"","code":"iso8601_two_digits(x)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_two_digits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format as a ISO8601 two-digit number — iso8601_two_digits","text":"x character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_two_digits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format as a ISO8601 two-digit number — iso8601_two_digits","text":"character vector size x.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_year.html","id":null,"dir":"Reference","previous_headings":"","what":"Format as a ISO8601 four-digit year — iso8601_year","title":"Format as a ISO8601 four-digit year — iso8601_year","text":"iso8601_year() converts character vector whose values represent years four-digit years.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_year.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format as a ISO8601 four-digit year — iso8601_year","text":"","code":"iso8601_year(x, cutoff_2000 = 68L)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_year.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format as a ISO8601 four-digit year — iso8601_year","text":"x character vector. cutoff_2000 non-negative integer value. Two-digit years smaller equal cutoff_2000 parsed though starting 20, otherwise parsed though starting 19.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/iso8601_year.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format as a ISO8601 four-digit year — iso8601_year","text":"character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/months_abb_regex.html","id":null,"dir":"Reference","previous_headings":"","what":"Regex for months' abbreviations — months_abb_regex","title":"Regex for months' abbreviations — months_abb_regex","text":"months_abb_regex() generates regex matches month abbreviations. finer control, case can specified parameter case.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/months_abb_regex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regex for months' abbreviations — months_abb_regex","text":"","code":"months_abb_regex(x = month.abb, case = c(\"any\", \"upper\", \"lower\", \"title\"))"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/months_abb_regex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regex for months' abbreviations — months_abb_regex","text":"x character vector three-letter month abbreviations. Default month.abb. case string scalar: \"\", month abbreviations matched case; \"upper\", match uppercase abbreviations; \"lower\", match lowercase; , \"title\" match title case.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/months_abb_regex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regex for months' abbreviations — months_abb_regex","text":"regex string.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/mutate.cnd_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Mutate method for conditioned data frames — mutate.cnd_df","title":"Mutate method for conditioned data frames — mutate.cnd_df","text":"mutate.cnd_df() S3 method dispatched mutate generic conditioned data frames. function implements conditional mutate changing rows condition stored conditioned data frame TRUE.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/mutate.cnd_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mutate method for conditioned data frames — mutate.cnd_df","text":"","code":"# S3 method for cnd_df mutate(   .data,   ...,   .by = NULL,   .keep = c(\"all\", \"used\", \"unused\", \"none\"),   .before = NULL,   .after = NULL )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/mutate.cnd_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mutate method for conditioned data frames — mutate.cnd_df","text":".data conditioned data frame. ... <data-masking> Name-value pairs. name gives name column output. value can : vector length 1, recycled correct length. vector length current group (whole data frame ungrouped). NULL, remove column. data frame tibble, create multiple columns output. .used .data conditioned data frame. .keep Control columns .data retained output. Grouping columns columns created ... always kept. \"\" retains columns .data. default. \"used\" retains columns used ... create new columns. useful checking work, displays inputs outputs side--side. \"unused\" retains columns used ... create new columns. useful generate new columns, longer need columns used generate . \"none\" retain extra columns .data. grouping variables columns created ... kept. .used, use .instead. .Control new columns appear, .e. columns.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/new_cnd_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a data frame with filtering tags — new_cnd_df","title":"Create a data frame with filtering tags — new_cnd_df","text":"new_cnd_df() creates conditioned data frame, classed cnd_df, meaning function extends data frame passed argument storing logical vector cnd (attribute) marks rows posterior conditional transformation methods support conditioned data frames.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/new_cnd_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a data frame with filtering tags — new_cnd_df","text":"","code":"new_cnd_df(dat, cnd, .warn = TRUE)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/new_cnd_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a data frame with filtering tags — new_cnd_df","text":"dat data frame. cnd logical vector. Length must match number rows dat. .warn Whether warn creating new conditioned data frame case dat already one.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/new_cnd_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a data frame with filtering tags — new_cnd_df","text":"data frame dat additional class \"cnd_df\" following attributes: cnd: logical vector passed argument cnd: TRUE values mark rows dat used transformations; rows marked FALSE transformed; NA mark rows whose transformations applied resulting NA. cnd_sum: integer vector three elements providing sum TRUE, FALSE NA values cnd, respectively.","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/oak_id_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Raw dataset keys — oak_id_vars","title":"Raw dataset keys — oak_id_vars","text":"oak_id_vars() helper function providing variable (column) names regarded keys tibbles representing raw datasets. default, set names oak_id, raw_source, patient_number. Extra variable names may indicated passed extra_vars appended default names.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/oak_id_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Raw dataset keys — oak_id_vars","text":"","code":"oak_id_vars(extra_vars = NULL)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/oak_id_vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Raw dataset keys — oak_id_vars","text":"extra_vars character vector extra column names appended default names: oak_id, raw_source, patient_number.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/oak_id_vars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Raw dataset keys — oak_id_vars","text":"character vector column names regarded keys raw datasets.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse a date, time, or date-time — parse_dttm_","title":"Parse a date, time, or date-time — parse_dttm_","text":"parse_dttm() extracts date time components. parse_dttm() wraps around parse_dttm_(), vectorized fmt.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse a date, time, or date-time — parse_dttm_","text":"","code":"parse_dttm_(   dttm,   fmt,   fmt_c = fmt_cmp(),   na = NULL,   sec_na = na,   min_na = na,   hour_na = na,   mday_na = na,   mon_na = na,   year_na = na )  parse_dttm(   dttm,   fmt,   fmt_c = fmt_cmp(),   na = NULL,   sec_na = na,   min_na = na,   hour_na = na,   mday_na = na,   mon_na = na,   year_na = na )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse a date, time, or date-time — parse_dttm_","text":"dttm character vector dates, times date-times. fmt case parse_dttm(), character vector parsing formats, single string format case parse_dttm_(). character vector formats passed, format attempted turn first parsing result successful taking precedence final result. formats fmt can strings, however following characters (successive repetitions thereof) reserved sense treated special way: \"y\": parsed year; \"m\": parsed month; \"d\": parsed day; \"H\": parsed hour; \"M\": parsed minute; \"S\": parsed second. na, sec_na, min_na, hour_na, mday_na, mon_na, year_na character vector alternative values allow matching. can used indicate different forms missing values found parsing date-time strings.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse a date, time, or date-time — parse_dttm_","text":"character matrix six columns: \"year\", \"mon\", \"mday\", \"hour\", \"min\" \"sec\". row corresponds element dttm. element matrix parsed date/time component.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm_fmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse a date/time format — parse_dttm_fmt_","title":"Parse a date/time format — parse_dttm_fmt_","text":"parse_dttm_fmt() parses date/time formats, meaning try parse components format fmt refer date/time components. parse_dttm_fmt_() similar parse_dttm_fmt() vectorized fmt.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm_fmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse a date/time format — parse_dttm_fmt_","text":"","code":"parse_dttm_fmt_(fmt, pattern)  parse_dttm_fmt(fmt, patterns = fmt_cmp())"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm_fmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse a date/time format — parse_dttm_fmt_","text":"fmt format string (scalar) parsed patterns. pattern, patterns string (case pattern), character vector (case patterns) regexps individual date/time components. Default value fmt_cmp(). Use function plan passing different set patterns.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/parse_dttm_fmt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse a date/time format — parse_dttm_fmt_","text":"tibble seven columns: fmt_c: date/time format component. Values either \"year\", \"mon\", \"mday\", \"hour\", \"min\", \"sec\", NA. pat: Regexp used parse date/time component. cap: captured substring format. start: Start position format string capture. end: End position format string capture. len: Length capture (number chars). ord: Ordinal date/time component format string. row either date/time format component \"delimiter\" string pattern -format components.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/problems.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve date/time parsing problems — problems","title":"Retrieve date/time parsing problems — problems","text":"problems() companion helper function create_iso8601(). retrieves ISO 8601 parsing problems object class iso8601, create_iso8601()'s return value might contain problems attribute case parsing failures. problems() helper function provides easy access parsing problems.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/problems.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve date/time parsing problems — problems","text":"","code":"problems(x = .Last.value)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/problems.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve date/time parsing problems — problems","text":"x object class iso8601, typically obtained call create_iso8601(). argument can also left empty, case problems() use last returned value, making convenient use immediately create_iso8601().","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/problems.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve date/time parsing problems — problems","text":"parsing problems x, returned value NULL; otherwise, tibble parsing failures returned. row corresponds parsing problem. first column named ..indicating position(s) inputs create_iso8601() call resulted failures; remaining columns correspond original input values passed create_iso8601(), columns automatically named ..var1, ..var2, , inputs create_iso8601() unnamed, otherwise, original variable names used instead.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/problems.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve date/time parsing problems — problems","text":"","code":"dates <-   c(     \"2020-01-01\",     \"2020-02-11\",     \"2020-01-06\",     \"2020-0921\",     \"2020/10/30\",     \"2020-12-05\",     \"20231225\"   )  # By inspecting the problematic dates it can be understood that # the `.format` parameter needs to updated to include other variations. iso8601_dttm <- create_iso8601(dates, .format = \"y-m-d\") problems(iso8601_dttm) #> # A tibble: 3 × 2 #>     ..i ..var1     #>   <int> <chr>      #> 1     4 2020-0921  #> 2     5 2020/10/30 #> 3     7 20231225    # Including more parsing formats addresses the previous problems formats <- c(\"y-m-d\", \"y-md\", \"y/m/d\", \"ymd\") iso8601_dttm2 <- create_iso8601(dates, .format = list(formats))  # So now `problems()` returns `NULL` because there are no more parsing issues. problems(iso8601_dttm2)  # If you pass named arguments when calling `create_iso8601()` then they will # be used to create the problems object. iso8601_dttm3 <- create_iso8601(date = dates, .format = \"y-m-d\") problems(iso8601_dttm3) #> # A tibble: 3 × 2 #>     ..i date       #>   <int> <chr>      #> 1     4 2020-0921  #> 2     5 2020/10/30 #> 3     7 20231225"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/pseq.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallel sequence generation — pseq","title":"Parallel sequence generation — pseq","text":"pseq() similar seq() conveniently accepts integer vectors inputs , allowing parallel generation sequences. result union generated sequences.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/pseq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallel sequence generation — pseq","text":"","code":"pseq(from, to)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/pseq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallel sequence generation — pseq","text":"integer vector. starting value(s) sequence(s). integer vector. ending value(s) sequence(s).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/pseq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallel sequence generation — pseq","text":"integer vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_ct_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Read in a controlled terminology — read_ct_spec","title":"Read in a controlled terminology — read_ct_spec","text":"read_ct_spec() imports controlled terminology specification data set tibble.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_ct_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read in a controlled terminology — read_ct_spec","text":"","code":"read_ct_spec(file = cli::cli_abort(\"`file` must be specified\"))"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_ct_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read in a controlled terminology — read_ct_spec","text":"file path file containing controlled terminology specification data set. following expected file: file expected CSV file; file expected contain first row column names; minimal set variables expected: codelist_code, collected_value, term_synonyms, term_value.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_ct_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read in a controlled terminology — read_ct_spec","text":"tibble controlled terminology specification.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_ct_spec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read in a controlled terminology — read_ct_spec","text":"","code":"# Get the local path to one of the controlled terminology example files. path <- ct_spec_example(\"ct-01-cm\")  # Import it to R. read_ct_spec(file = path) #> # A tibble: 33 × 8 #>    codelist_code term_code CodedData term_value collected_value     #>    <chr>         <chr>     <chr>     <chr>      <chr>               #>  1 C71113        C25473    QD        QD         QD (Every Day)      #>  2 C71113        C64496    BID       BID        BID (Twice a Day)   #>  3 C71113        C64499    PRN       PRN        PRN (As Needed)     #>  4 C71113        C64516    Q2H       Q2H        Q2H (Every 2 Hours) #>  5 C71113        C64530    QID       QID        QID (4 Times a Day) #>  6 C66726        C25158    CAPSULE   CAPSULE    Capsule             #>  7 C66726        C25394    PILL      PILL       Pill                #>  8 C66726        C29167    LOTION    LOTION     Lotion              #>  9 C66726        C42887    AEROSOL   AEROSOL    Aerosol             #> 10 C66726        C42944    INHALANT  INHALANT   Inhalant            #> # ℹ 23 more rows #> # ℹ 3 more variables: term_preferred_term <chr>, term_synonyms <chr>, #> #   raw_codelist <chr>"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_ct_spec_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Read an example controlled terminology specification — read_ct_spec_example","title":"Read an example controlled terminology specification — read_ct_spec_example","text":"read_ct_spec_example() imports one bundled controlled terminology specification data sets tibble R.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_ct_spec_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read an example controlled terminology specification — read_ct_spec_example","text":"","code":"read_ct_spec_example(example)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_ct_spec_example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read an example controlled terminology specification — read_ct_spec_example","text":"example file name controlled terminology data set bundled {stdm.oak}, run read_ct_spec_example() available example files.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_ct_spec_example.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read an example controlled terminology specification — read_ct_spec_example","text":"tibble controlled terminology specification data set, character vector example file names.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_ct_spec_example.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read an example controlled terminology specification — read_ct_spec_example","text":"","code":"# Leave the `example` parameter as missing for available example files. read_ct_spec_example() #> [1] \"ct-01-cm.csv\"  # Read an example controlled terminology spec file. read_ct_spec_example(\"ct-01-cm.csv\") #> # A tibble: 33 × 8 #>    codelist_code term_code CodedData term_value collected_value     #>    <chr>         <chr>     <chr>     <chr>      <chr>               #>  1 C71113        C25473    QD        QD         QD (Every Day)      #>  2 C71113        C64496    BID       BID        BID (Twice a Day)   #>  3 C71113        C64499    PRN       PRN        PRN (As Needed)     #>  4 C71113        C64516    Q2H       Q2H        Q2H (Every 2 Hours) #>  5 C71113        C64530    QID       QID        QID (4 Times a Day) #>  6 C66726        C25158    CAPSULE   CAPSULE    Capsule             #>  7 C66726        C25394    PILL      PILL       Pill                #>  8 C66726        C29167    LOTION    LOTION     Lotion              #>  9 C66726        C42887    AEROSOL   AEROSOL    Aerosol             #> 10 C66726        C42944    INHALANT  INHALANT   Inhalant            #> # ℹ 23 more rows #> # ℹ 3 more variables: term_preferred_term <chr>, term_synonyms <chr>, #> #   raw_codelist <chr>  # You may omit the file extension. read_ct_spec_example(\"ct-01-cm\") #> # A tibble: 33 × 8 #>    codelist_code term_code CodedData term_value collected_value     #>    <chr>         <chr>     <chr>     <chr>      <chr>               #>  1 C71113        C25473    QD        QD         QD (Every Day)      #>  2 C71113        C64496    BID       BID        BID (Twice a Day)   #>  3 C71113        C64499    PRN       PRN        PRN (As Needed)     #>  4 C71113        C64516    Q2H       Q2H        Q2H (Every 2 Hours) #>  5 C71113        C64530    QID       QID        QID (4 Times a Day) #>  6 C66726        C25158    CAPSULE   CAPSULE    Capsule             #>  7 C66726        C25394    PILL      PILL       Pill                #>  8 C66726        C29167    LOTION    LOTION     Lotion              #>  9 C66726        C42887    AEROSOL   AEROSOL    Aerosol             #> 10 C66726        C42944    INHALANT  INHALANT   Inhalant            #> # ℹ 23 more rows #> # ℹ 3 more variables: term_preferred_term <chr>, term_synonyms <chr>, #> #   raw_codelist <chr>"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_domain_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Read an example SDTM domain — read_domain_example","title":"Read an example SDTM domain — read_domain_example","text":"read_domain_example() imports one bundled SDTM domain examples tibble R. See domain_example() possible choices.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_domain_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read an example SDTM domain — read_domain_example","text":"","code":"read_domain_example(example)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_domain_example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read an example SDTM domain — read_domain_example","text":"example name SDTM domain example, e.g. \"cm\" (Concomitant Medication) \"ae\" (Adverse Events). Run read_domain_example() available example files.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_domain_example.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read an example SDTM domain — read_domain_example","text":"tibble SDTM domain dataset, character vector example file names.","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/read_domain_example.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read an example SDTM domain — read_domain_example","text":"","code":"# Leave the `example` parameter as missing for available example files. read_domain_example() #> [1] \"ae\"   \"apsc\" \"cm\"   \"vs\"    # Read the example Concomitant Medication domain. read_domain_example(\"cm\") #> # A tibble: 7,510 × 21 #>    STUDYID DOMAIN USUBJID CMSEQ CMSPID CMTRT CMDECOD CMINDC CMCLAS CMDOSE CMDOSU #>    <chr>   <chr>  <chr>   <dbl> <chr>  <chr> <chr>   <chr>  <chr>   <dbl> <chr>  #>  1 CDISCP… CM     01-701…     1 1      ASPI… ACETYL… NA     NERVO…      1 TABLET #>  2 CDISCP… CM     01-701…     5 1      ASPI… ACETYL… NA     NERVO…      1 TABLET #>  3 CDISCP… CM     01-701…     9 1      ASPI… ACETYL… NA     NERVO…      1 TABLET #>  4 CDISCP… CM     01-701…    13 1      ASPI… ACETYL… NA     NERVO…      1 TABLET #>  5 CDISCP… CM     01-701…    18 1      ASPI… ACETYL… NA     NERVO…      1 TABLET #>  6 CDISCP… CM     01-701…    23 1      ASPI… ACETYL… NA     NERVO…      1 TABLET #>  7 CDISCP… CM     01-701…    28 1      ASPI… ACETYL… NA     NERVO…      1 TABLET #>  8 CDISCP… CM     01-701…    33 1      ASPI… ACETYL… NA     NERVO…      1 TABLET #>  9 CDISCP… CM     01-701…    38 1      ASPI… ACETYL… NA     NERVO…      1 TABLET #> 10 CDISCP… CM     01-701…    43 1      ASPI… ACETYL… NA     NERVO…      1 TABLET #> # ℹ 7,500 more rows #> # ℹ 10 more variables: CMDOSFRQ <chr>, CMROUTE <chr>, VISITNUM <dbl>, #> #   VISIT <chr>, VISITDY <dbl>, CMDTC <chr>, CMSTDTC <chr>, CMENDTC <chr>, #> #   CMSTDY <dbl>, CMENDY <dbl>  # Read the example Adverse Events domain. read_domain_example(\"ae\") #> # A tibble: 1,191 × 35 #>    STUDYID DOMAIN USUBJID AESEQ AESPID AETERM AELLT AELLTCD AEDECOD AEPTCD AEHLT #>    <chr>   <chr>  <chr>   <dbl> <chr>  <chr>  <chr>   <dbl> <chr>    <dbl> <chr> #>  1 CDISCP… AE     01-701…     1 E07    APPLI… APPL…      NA APPLIC…     NA HLT_… #>  2 CDISCP… AE     01-701…     2 E08    APPLI… APPL…      NA APPLIC…     NA HLT_… #>  3 CDISCP… AE     01-701…     3 E06    DIARR… DIAR…      NA DIARRH…     NA HLT_… #>  4 CDISCP… AE     01-701…     3 E10    ATRIO… AV B…      NA ATRIOV…     NA HLT_… #>  5 CDISCP… AE     01-701…     1 E08    ERYTH… ERYT…      NA ERYTHE…     NA HLT_… #>  6 CDISCP… AE     01-701…     2 E09    ERYTH… LOCA…      NA ERYTHE…     NA HLT_… #>  7 CDISCP… AE     01-701…     4 E08    ERYTH… ERYT…      NA ERYTHE…     NA HLT_… #>  8 CDISCP… AE     01-701…     1 E04    APPLI… APPL…      NA APPLIC…     NA HLT_… #>  9 CDISCP… AE     01-701…     2 E05    APPLI… APPL…      NA APPLIC…     NA HLT_… #> 10 CDISCP… AE     01-701…     1 E08    APPLI… APPL…      NA APPLIC…     NA HLT_… #> # ℹ 1,181 more rows #> # ℹ 24 more variables: AEHLTCD <dbl>, AEHLGT <chr>, AEHLGTCD <dbl>, #> #   AEBODSYS <chr>, AEBDSYCD <dbl>, AESOC <chr>, AESOCCD <dbl>, AESEV <chr>, #> #   AESER <chr>, AEACN <chr>, AEREL <chr>, AEOUT <chr>, AESCAN <chr>, #> #   AESCONG <chr>, AESDISAB <chr>, AESDTH <chr>, AESHOSP <chr>, AESLIFE <chr>, #> #   AESOD <chr>, AEDTC <chr>, AESTDTC <chr>, AEENDTC <chr>, AESTDY <dbl>, #> #   AEENDY <dbl>"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/recode.html","id":null,"dir":"Reference","previous_headings":"","what":"Recode values — recode","title":"Recode values — recode","text":"recode() recodes values x matching elements onto values .","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/recode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recode values — recode","text":"","code":"recode(x, from = unique(na.omit(x)), to = from, .no_match = x, .na = NA)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/recode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recode values — recode","text":"x atomic vector values recoded. vector values matched x recoding. vector values used replacement values . .no_match Value used replacement cases matched. .na Value used recode missing values.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/recode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recode values — recode","text":"vector recoded values.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/reg_matches.html","id":null,"dir":"Reference","previous_headings":"","what":"regmatches() with NA — reg_matches","title":"regmatches() with NA — reg_matches","text":"reg_matches() thin wrapper around regmatches() returns NA instead character(0) matching fails.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/reg_matches.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"regmatches() with NA — reg_matches","text":"","code":"reg_matches(x, m, invert = FALSE)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/reg_matches.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"regmatches() with NA — reg_matches","text":"x character vector. m object match data. invert logical scalar. TRUE, extract replace non-matched substrings.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/reg_matches.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"regmatches() with NA — reg_matches","text":"list character vectors matched substrings, NA matching failed.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/regex_or.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility function to assemble a regex of alternative patterns — regex_or","title":"Utility function to assemble a regex of alternative patterns — regex_or","text":"regex_or() takes set patterns binds (\"|\") pattern easy regex alternative patterns.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/regex_or.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility function to assemble a regex of alternative patterns — regex_or","text":"","code":"regex_or(x, .open = FALSE, .close = FALSE)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/regex_or.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility function to assemble a regex of alternative patterns — regex_or","text":"x character vector alternative patterns. .open Whether resulting regex start \"|\". .close Whether resulting regex end \"|\".","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/regex_or.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility function to assemble a regex of alternative patterns — regex_or","text":"character scalar resulting regex.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/rm_cnd_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove the cnd_df class from a data frame — rm_cnd_df","title":"Remove the cnd_df class from a data frame — rm_cnd_df","text":"function removes cnd_df class, along attributes, applicable.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/rm_cnd_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove the cnd_df class from a data frame — rm_cnd_df","text":"","code":"rm_cnd_df(dat)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/rm_cnd_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove the cnd_df class from a data frame — rm_cnd_df","text":"dat data frame.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/rm_cnd_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove the cnd_df class from a data frame — rm_cnd_df","text":"input dat without cnd_df class associated attributes.","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sbj_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Subject-level key variables — sbj_vars","title":"Subject-level key variables — sbj_vars","text":"sbj_vars() returns set variable names uniquely define subject.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sbj_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subject-level key variables — sbj_vars","text":"","code":"sbj_vars()"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sbj_vars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subject-level key variables — sbj_vars","text":"character vector variable names.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sbj_vars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subject-level key variables — sbj_vars","text":"","code":"sbj_vars() #> [1] \"STUDYID\" \"USUBJID\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm.oak-package.html","id":null,"dir":"Reference","previous_headings":"","what":"sdtm.oak: SDTM Data Transformation Engine — sdtm.oak-package","title":"sdtm.oak: SDTM Data Transformation Engine — sdtm.oak-package","text":"EDC Data Standard-agnostic SDTM data transformation engine designed SDTM programming R. Powered metadata sdtm.oak can automate conversion raw clinical data SDTM standardized mapping algorithms. SDTM one required standards data submission FDA (U.S.) PMDA (Japan). SDTM standards implemented accordance SDTM Implementation Guide defined CDISC https://www.cdisc.org/standards/foundational/sdtmig.","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm.oak-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"sdtm.oak: SDTM Data Transformation Engine — sdtm.oak-package","text":"Maintainer: Rammprasad Ganapathy ganapathy.rammprasad@gene.com Authors: Adam Forys Edgar Manukyan Rosemary Li Preetesh Parikh Lisa Houterloot Yogesh Gupta Omar Garcia ogcalderon@cdisc.org Ramiro Magno rmagno@pattern.institute (ORCID) Kamil Sijko kamil.sijko@ttsi.com.pl (ORCID) Shiyu Chen Shiyu.Chen@atorusresearch.com contributors: Pattern Institute [copyright holder, funder] F. Hoffmann-La Roche AG [copyright holder, funder] Pfizer Inc [copyright holder, funder] Transition Technologies Science [copyright holder, funder]","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm_assign.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive an SDTM variable — sdtm_assign","title":"Derive an SDTM variable — sdtm_assign","text":"sdtm_assign() internal function packing functionality assign_no_ct() assign_ct() together aimed developers . user please use either assign_no_ct() assign_ct().","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm_assign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive an SDTM variable — sdtm_assign","text":"","code":"sdtm_assign(   tgt_dat = NULL,   tgt_var,   raw_dat,   raw_var,   ct_spec = NULL,   ct_clst = NULL,   id_vars = oak_id_vars() )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm_assign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive an SDTM variable — sdtm_assign","text":"tgt_dat Target dataset: data frame merged raw_dat variables indicated id_vars. parameter optional, see section Value output changes depending argument value. tgt_var target SDTM variable: single string indicating name variable derived. raw_dat raw dataset (dataframe); must include variables passed id_vars raw_var. raw_var raw variable: single string indicating name raw variable raw_dat. ct_spec Study controlled terminology specification: dataframe minimal set columns, see ct_spec_vars() details. parameter optional, left NULL controlled terminology recoding applied. ct_clst codelist code indicating subset controlled terminology apply derivation. parameter optional, left NULL, possible recodings ct_spec attempted. id_vars Key variables used join raw dataset (raw_dat) target data set (tgt_dat).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm_assign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive an SDTM variable — sdtm_assign","text":"returned data set depends value tgt_dat: target dataset supplied, meaning tgt_dat defaults NULL, returned data set raw_dat, selected variables indicated id_vars, new extra column: derived variable, indicated tgt_var. target dataset provided, merged raw data set raw_dat variables indicated id_vars, new column: derived variable, indicated tgt_var.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm_hardcode.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive an SDTM variable with a hardcoded value — sdtm_hardcode","title":"Derive an SDTM variable with a hardcoded value — sdtm_hardcode","text":"sdtm_hardcode() internal function packing functionality hardcode_no_ct() hardcode_ct() together aimed developers . user please use either hardcode_no_ct() hardcode_ct().","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm_hardcode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive an SDTM variable with a hardcoded value — sdtm_hardcode","text":"","code":"sdtm_hardcode(   tgt_dat = NULL,   tgt_var,   raw_dat,   raw_var,   tgt_val,   ct_spec = NULL,   ct_clst = NULL,   id_vars = oak_id_vars() )"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm_hardcode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive an SDTM variable with a hardcoded value — sdtm_hardcode","text":"tgt_dat Target dataset: data frame merged raw_dat variables indicated id_vars. parameter optional, see section Value output changes depending argument value. tgt_var target SDTM variable: single string indicating name variable derived. raw_dat raw dataset (dataframe); must include variables passed id_vars raw_var. raw_var raw variable: single string indicating name raw variable raw_dat. tgt_val target SDTM value hardcoded variable indicated tgt_var. ct_spec Study controlled terminology specification: dataframe minimal set columns, see ct_spec_vars() details. parameter optional, left NULL controlled terminology recoding applied. ct_clst codelist code indicating subset controlled terminology apply derivation. parameter optional, left NULL, possible recodings ct_spec attempted. id_vars Key variables used join raw dataset (raw_dat) target data set (tgt_dat).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm_hardcode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive an SDTM variable with a hardcoded value — sdtm_hardcode","text":"returned data set depends value tgt_dat: target dataset supplied, meaning tgt_dat defaults NULL, returned data set raw_dat, selected variables indicated id_vars, new extra column: derived variable, indicated tgt_var. target dataset provided, merged raw data set raw_dat variables indicated id_vars, new column: derived variable, indicated tgt_var.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm_join.html","id":null,"dir":"Reference","previous_headings":"","what":"SDTM join — sdtm_join","title":"SDTM join — sdtm_join","text":"sdtm_join() special join raw data set target data set. function supports conditioned data frames. sdtm_join() special join raw data set target data set. function supports conditioned data frames.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SDTM join — sdtm_join","text":"","code":"sdtm_join(raw_dat, tgt_dat = NULL, id_vars = oak_id_vars())  sdtm_join(raw_dat, tgt_dat = NULL, id_vars = oak_id_vars())"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SDTM join — sdtm_join","text":"raw_dat raw dataset: dataframe conditioned data frame. Must include variables passed id_vars. tgt_dat Target dataset: data frame conditioned data frame merged raw_dat variables indicated id_vars. id_vars Key variables used join raw dataset (raw_dat) target data set (tgt_dat).","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/sdtm_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SDTM join — sdtm_join","text":"data frame, conditioned data frame least one input data sets conditioned data frame. data frame, conditioned data frame , least, one input data sets conditioned data frame.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/str_to_anycase.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate case insensitive regexps — str_to_anycase","title":"Generate case insensitive regexps — str_to_anycase","text":"str_to_anycase() takes character vector word strings input, generates regular expressions express match case.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/str_to_anycase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate case insensitive regexps — str_to_anycase","text":"","code":"str_to_anycase(x)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/str_to_anycase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate case insensitive regexps — str_to_anycase","text":"x character vector strings consisting word characters.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/str_to_anycase.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate case insensitive regexps — str_to_anycase","text":"character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/tbl_sum.cnd_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditioned tibble header print method — tbl_sum.cnd_df","title":"Conditioned tibble header print method — tbl_sum.cnd_df","text":"Conditioned tibble header print method. S3 method adds extra line header tibble indicates tibble conditioned tibble (# Cond. tbl:) followed tally conditioning vector: number TRUE, FALSE NA values: e.g., 1/1/1.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/tbl_sum.cnd_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditioned tibble header print method — tbl_sum.cnd_df","text":"","code":"# S3 method for cnd_df tbl_sum(x, ...)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/tbl_sum.cnd_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditioned tibble header print method — tbl_sum.cnd_df","text":"x conditioned tibble class cnd_df. ... Additional arguments passed default print method.","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/tbl_sum.cnd_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditioned tibble header print method — tbl_sum.cnd_df","text":"","code":"df <- data.frame(x = c(1L, NA_integer_, 3L)) (cnd_df <- condition_add(dat = df, x >= 2L)) #> # A tibble:  3 × 1 #> # Cond. tbl: 1/1/1 #>         x #>     <int> #> 1 F     1 #> 2 -    NA #> 3 T     3 pillar::tbl_sum(cnd_df) #>  A tibble Cond. tbl  #>   \"3 × 1\"   \"1/1/1\""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/yy_to_yyyy.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert two-digit to four-digit years — yy_to_yyyy","title":"Convert two-digit to four-digit years — yy_to_yyyy","text":"yy_to_yyyy() converts two-digit years four-digit years.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/yy_to_yyyy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert two-digit to four-digit years — yy_to_yyyy","text":"","code":"yy_to_yyyy(x, cutoff_2000 = 68L)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/yy_to_yyyy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert two-digit to four-digit years — yy_to_yyyy","text":"x integer vector years. cutoff_2000 integer value. Two-digit years smaller equal cutoff_2000 parsed though starting 20, otherwise parsed though starting 19.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/yy_to_yyyy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert two-digit to four-digit years — yy_to_yyyy","text":"integer vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/zero_pad_whole_number.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an integer to a zero-padded character vector — zero_pad_whole_number","title":"Convert an integer to a zero-padded character vector — zero_pad_whole_number","text":"zero_pad_whole_number() takes non-negative integer values converts character zero padding. Negative numbers numbers greater width specified number digits n converted NA.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/zero_pad_whole_number.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an integer to a zero-padded character vector — zero_pad_whole_number","text":"","code":"zero_pad_whole_number(x, n = 2L)"},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/zero_pad_whole_number.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an integer to a zero-padded character vector — zero_pad_whole_number","text":"x integer vector. n Number digits output, including zero padding.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/reference/zero_pad_whole_number.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert an integer to a zero-padded character vector — zero_pad_whole_number","text":"character vector.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/news/index.html","id":"sdtmoak-0009005-development-version","dir":"Changelog","previous_headings":"","what":"sdtm.oak 0.0.0.9005 (development version)","title":"sdtm.oak 0.0.0.9005 (development version)","text":"New function creating conditioned data frames: condition_add(). New pipe operator: %.>% explicit dot placeholder placement. oak_id_vars() now exported function.","code":""},{"path":"https://pharmaverse.github.io/sdtm.oak/news/index.html","id":"sdtmoak-0009004-development-version","dir":"Changelog","previous_headings":"","what":"sdtm.oak 0.0.0.9004 (development version)","title":"sdtm.oak 0.0.0.9004 (development version)","text":"New function: derive_seq() deriving sequence number variable.","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/news/index.html","id":"new-features-0-0-0-9003","dir":"Changelog","previous_headings":"","what":"New Features","title":"sdtm.oak 0.0.0.9003 (development version)","text":"New function: assign_datetime() deriving ISO8601 date-time variable.","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/news/index.html","id":"new-features-0-0-0-9002","dir":"Changelog","previous_headings":"","what":"New Features","title":"sdtm.oak 0.0.0.9002 (development version)","text":"New function: derive_study_day() study day calculation. New functions basic SDTM derivations: assign_no_ct(), assign_ct(), hardcode_no_ct() hardcode_ct(). New functions handling controlled terminologies: read_ct_spec(), read_ct_spec_example(), ct_spec_example() ct_map().","code":""},{"path":[]},{"path":"https://pharmaverse.github.io/sdtm.oak/news/index.html","id":"new-features-0-0-0-9001","dir":"Changelog","previous_headings":"","what":"New Features","title":"sdtm.oak 0.0.0.9001 (development version)","text":"New function create_iso8601() conversion vectors dates, times date-times ISO8601 format.","code":""}]
