---
title: "Converting dates/times to ISO 8601"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(sdtm.oak)
```

An SDTM DTC variable may include data that is represented in [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) format as a complete date/time, a
partial date/time, or an incomplete date/time. `{sdtm.oak}` provides the
`create_iso8601()` function that allows flexible mapping of date and time
values in various formats to a single date-time ISO 8601 format.

## Introduction

To perform conversion to the ISO 8601 format you need to pass two key arguments:

- At least one vector of dates, times, or date-times of `character` type;
- A date/time format via the `.format` parameter that instructs `create_iso8601()` on which date/time components to expect.

```{r}
create_iso8601("2000 01 05", .format = "y m d")
create_iso8601("22:35:05", .format = "H:M:S")
```

By default the `.format` parameter understands a few reserved characters:

- `"y"` for year
- `"m"` for month
- `"d"` for day
- `"H"` for hours
- `"M"` for minutes
- `"S"` for seconds

Besides character vectors of dates and times, you may also pass a single vector
of date-times, provided you adjust the format:

```{r}
create_iso8601("2000-01-05 22:35:05", .format = "y-m-d H:M:S")
```

If you have dates and times in separate vectors then you will need to pass
a format for each vector:

```{r}
create_iso8601("2000-01-05", "22:35:05", .format = c("y-m-d", "H:M:S"))
```



## `create_iso8601()` is vectorized over inputs

```{r}
date <- c("2000-01-05", "2001-12-25", "1980-06-18", "1979-09-07")
time <- c("00:12:21", "22:35:05", "03:00:15", "07:09:00")
create_iso8601(date, time, .format = c("y-m-d", "H:M:S"))
```

But the number of elements in each of the inputs has to match or you will get an
error:

```{r}
date <- c("2000-01-05", "2001-12-25", "1980-06-18", "1979-09-07")
time <- "00:12:21"
try(create_iso8601(date, time, .format = c("y-m-d", "H:M:S")))
```

## The `.format` parameter

The `.format` parameter can easily accommodate variations in the format of the
inputs:

```{r}
create_iso8601("2000-01-05", .format = "y-m-d")
create_iso8601("2000 01 05", .format = "y m d")
create_iso8601("2000/01/05", .format = "y/m/d")
```

Individual components may come in a different order, so adjust the format
accordingly:

```{r}
create_iso8601("2000 01 05", .format = "y m d")
create_iso8601("05 01 2000", .format = "d m y")
create_iso8601("01 05, 2000", .format = "m d, y")
```

All other individual characters given in the format are taken strictly, so
one space is different from two:

```{r}
date <- c("2000 01 05", "2000  01 05", "2000 01  05", "2000   01   05")
create_iso8601(date, .format = "y m d")
create_iso8601(date, .format = "y  m d")
create_iso8601(date, .format = "y m  d")
create_iso8601(date, .format = "y   m   d")
```

The format can include regular expressions though:

```{r}
create_iso8601(date, .format = "y\\s+m\\s+d")
```

### Multiple alternative formats

When an input vector contains values with varying formats, a single format may
not be adequate to encompass all variations. In such situations, it's advisable
to list multiple alternative formats. This approach ensures that each format is
tried sequentially until one matches the data in the vector.

```{r}
date <- c("2000/01/01", "2000-01-02", "2000 01 03", "2000/01/04")
create_iso8601(date, .format = "y-m-d")
create_iso8601(date, .format = "y m d")
create_iso8601(date, .format = "y/m/d")
create_iso8601(date, .format = list(c("y-m-d", "y m d", "y/m/d")))
```

Consider the order in which you supply the formats, as it can be significant. If
multiple formats could potentially match, the sequence determines which format
is applied first.

```{r}
create_iso8601("07 04 2000", .format = list(c("d m y", "m d y")))
create_iso8601("07 04 2000", .format = list(c("m d y", "d m y")))
```

## Individual date/time components

Each individual date or time component is parsed as per the indication in the
format according to certain constraints:

```{r}
# Years: two-digit or four-digit numbers.
years <- c("0", "1", "00", "01", "15", "30", "50", "68", "69", "80", "99")
create_iso8601(years, .format = "y")

# Adjust the point where two-digits years are mapped to 2000's or 1900's.
create_iso8601(years, .format = "y", .cutoff_2000 = 20L)

# Both numeric months (two-digit only) and abbreviated months work out of the box
months <- c("0", "00", "1", "01", "Jan", "jan")
create_iso8601(months, .format = "m")

# Month days: single or two-digit numbers, anything else results in NA.
create_iso8601(c("1", "01", "001", "10", "20", "31"), .format = "d")

# Hours
create_iso8601(c("1", "01", "001", "10", "20", "31"), .format = "H")

# Minutes
create_iso8601(c("1", "01", "001", "10", "20", "60"), .format = "M")

# Seconds
create_iso8601(c("1", "01", "001", "10", "20", "60"), .format = "S")
```
